[{"categories":["今日份"],"content":"正式工作之后没有太多的时间精力经营自己的博客，最近又关注到这个问题，觉得不更新实在是可惜。 唤醒一下我的博客，以后就不定期更新。 ","date":"2025-01-18","objectID":"/2025/01/18/2025-01-19-%E5%94%A4%E9%86%92/:0:0","tags":null,"title":"唤醒我的博客","uri":"/2025/01/18/2025-01-19-%E5%94%A4%E9%86%92/"},{"categories":["English Daily"],"content":" 财富 = 专注 + (stoicism自律 x 时间 x 多样化) This is the first lesson in this book: economic security isn’t a function of what you earn but what you keep and knowing how much is enough for you. 这本书的第一课，财富自由不是你能够赚多少钱而是你能够存多少钱并且知道有多少钱对你来说是足够的。 财富自由 = 被动收入 \u003e 日常支出 ","date":"2024-10-01","objectID":"/2024/10/01/day10-the-algebra-of-wealth/:0:0","tags":["The Algebraof Wealth"],"title":"day10","uri":"/2024/10/01/day10-the-algebra-of-wealth/"},{"categories":["今日份"],"content":"1、工作时，不分哪些是该做的，哪些是不该做的 我有时会听到这样的描述，那件事儿不是我负责，我不清楚；其他同事来问问题也不愿意提供帮助。而张一鸣，昨晚自己的工作之后，对于大部分同事的问题，只要能够帮助解决，他都去做。他每天十二点一点下班，放到现在的工作环境，大家可能会觉得这人是个卷王，这人也许很傻，公司又不会多给钱，类似需求是做不完的这样的言论也不在少数。 我觉得这不是一个保持自我成长的年轻人该有的特质，努力去做事情才能有成长。 2、打破工种的边界 张一鸣当时负责技术，但遇到产品问题，也会积极讨论。和销售总监一起去见客户让他知道：怎样的销售才是好的销售。技术、产品、销售、商业，这不就是一个公司的要素吗？后来这些东西对张一鸣也有很大的帮助。这就是走过的路都不白走。 我曾经有机会和自己公司的领导有过交流，发现他们都有“通才”的特质，你要管的事情或许不精通，但你至少要懂一些，至少知道什么样是好的，什么样是坏的。 3、对不确定性保持乐观，积极主动尝试 张一鸣提到头条最开始时，他跟大家讲：他们要做1亿的日启动次数。现在看这句话没什么问题，但在最开始呢？一个名不见经传的小公司，他说他要做1亿的日启动，一些人可能会觉得是天方夜谭。 我敢肯定，这些人一定做不到，因为他都没有尝试过。 而乐观的人呢？他会勇于去尝试，最后能不能做到其实没关系，你在做的过程中得到的提升已经是一笔宝贵的财富了。 4、不甘于平庸，最高标准，不傲娇 如果你的目标只是落户买房，精力都放在这上面，工作会受到很大影响。我知道一些人会说，这个目标不是已经够高了吗？仔细想一想，这个目标对于大多数人来讲，已经很高了。 但这只是过程，不是最终目标。 “不甘于平庸”是你目标要设得很高，“不傲娇”是你对现状要踏实。 5、对重要的事情有判断力 选什么专业、选什么公司、选什么职业、选什么发展路径，自己要有判断力，不要被短期选择而左右。 我自己在选工作时确实被这个因素左右了，不过我仍旧认为我现在的工作是我现阶段最好的解，当然，对重要事情有判断力这点是需要我不断学习的。 https://leoxiewl.github.io/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/ ","date":"2024-09-11","objectID":"/2024/09/11/2024-09-11-stay-hungry-stay-young/:0:0","tags":null,"title":"从张一鸣Stay hungry, Stay Young演讲中学到的东西","uri":"/2024/09/11/2024-09-11-stay-hungry-stay-young/"},{"categories":["好文分享"],"content":"大家好！ 各位都非常年轻，我今天来的时候挺有压力，因为我毕业快11年了，看到你们，真是觉得“长江后浪推前浪”。 我去年参加了武汉的校招，感觉新一代年轻人的素质确实都非常好。我作为面试官，过去10年里，可能面试过小2000个年轻人。有的和我在一家公司，有的去了别家公司，他们发展差别其实非常大。那为何毕业多年后，原本水平差不多的同学都拉开了差距？ 我昨天就在想这个问题，也在想应该跟大家分享些什么。 想了想，先把题目拟出来，把乔布斯的“Stay hungry, Stay foolish”，改成“Stay hungry, Stay Young”。 什么是“Stay hungry, Stay Young”？“Stay hungry”，大家都知道，就是好奇心、求知若渴、上进心。 但为什么要说“Stay Young”？ 我觉得年轻人有很多优点：做事不设条条框框，没有太多自我要维护，经常能打破常规，非常努力、不妥协、不圆滑世故。 10年过去了，有的年轻人，依然保持着这些很好的特质，我觉得这就算“Stay Young”。“Stay Young”的人基本没有到天花板，一直保持着自我的成长。 相反，很多人毕业后提高了技能，但到一个天花板后，就不再成长了。 先分享我的个人经历吧。 我是如何在毕业第2年，就成了管理四五十人团队的主管？ 2005年，我从南开大学毕业，加入了一家公司叫酷讯。我是最早期加入的员工之一，一开始只是一个普通工程师。 但在工作第 2 年，我在公司管了四五十个人的团队，负责所有后端技术，同时也负责很多产品相关的工作。 有人问我： 为什么你在第一份工作就成长很快？是不是你在那个公司表现特别突出？ 其实不是，当时公司招聘标准也很高。跟我同期入职的，我记得就有两个清华计算机系的博士。 那我是不是技术最好？是不是最有经验？ 我发现都不是。后来我想了想，当时自己有哪些特质。 ","date":"2024-09-10","objectID":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/:0:0","tags":null,"title":"张一鸣：Stay hungry, Stay Young","uri":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/"},{"categories":["好文分享"],"content":"1、我工作时，不分哪些是我该做的、哪些不是我该做的 我做完自己的工作后，对于大部分同事的问题，只要我能帮助解决，我都去做。当时，Code Base中大部分代码我都看过了；新人入职时，只要我有时间，我都给他讲解一遍。通过讲解，我自己也能得到成长。还有一个特点，工作前两年，我基本上每天都是十二点一点回家，回家以后也编程到挺晚。确实是因为有兴趣，而不是公司有要求。所以我很快从负责一个抽取爬虫的模块，到负责整个后端系统，开始带一个小组，后来带一个小部门，再后来带一个大部门。 ","date":"2024-09-10","objectID":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/:1:0","tags":null,"title":"张一鸣：Stay hungry, Stay Young","uri":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/"},{"categories":["好文分享"],"content":"2、我做事从不设边界 当时我负责技术，但遇到产品上有问题，也会积极地参与讨论、想产品的方案。 很多人说这个不是我该做的事情。 但我想说： 你的责任心，你希望把事情做好的动力，会驱动你做更多事情，让你得到很大的锻炼。 我当时是工程师，但参与产品的经历，对我后来转型做产品有很大帮助。 我参与商业的部分，对我现在的工作也有很大帮助。记得在07年底，我跟公司的销售总监一起去见客户。这段经历让我知道：怎样的销售才是好的销售。当我组建头条招人时，这些可供参考的案例，让我在这个领域不会一无所知。 以上就是我刚毕业时的特点。 通过我十年的观察，我遇到的优秀的年轻人，都有这5大特质！ 后来，我陆续加入到各种创业团队。在这个过程中，我跟很多毕业生共处过，现在还和他们很多人保持联系。 跟大家分享一下，我看到的一些好和不好的情况。 ","date":"2024-09-10","objectID":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/:2:0","tags":null,"title":"张一鸣：Stay hungry, Stay Young","uri":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/"},{"categories":["好文分享"],"content":"优秀年轻人5大特质 总结一下，这些优秀年轻人有哪些特质呢？ ","date":"2024-09-10","objectID":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/:3:0","tags":null,"title":"张一鸣：Stay hungry, Stay Young","uri":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/"},{"categories":["好文分享"],"content":"第一，有好奇心，能够主动学习新事物、新知识和新技能 今天不太谦虚，我把自己当做正例，然后再说一个负例。 我有个前同事，理论基础挺好，但每次都是把自己的工作做完就下班了。 他在这家公司呆了一年多，但对网上的新技术、新工具都不去了解。 所以他非常依赖别人。 当他想要实现一个功能，他就需要有人帮他做后半部分，因为他自己只能做前半部分。 如果是有好奇心的人，前端、后端、算法都去掌握、至少有所了解的话，那么很多调试分析，自己一个人就可以做。 ","date":"2024-09-10","objectID":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/:3:1","tags":null,"title":"张一鸣：Stay hungry, Stay Young","uri":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/"},{"categories":["好文分享"],"content":"第二，对不确定性保持乐观 比方说头条最开始时，我跟大家讲：我们要做1亿的日启动次数。（当然，现在不止1亿了，我们现在的日启动次数已经差不多5亿。） 很多人觉得，你这家小公司怎么可能做得到呢？大公司才能做得好。 所以他就不敢努力去尝试。只有乐观的人会相信，会愿意去尝试。 其实我加入酷讯时也是这样。 那家公司当时想做下一代搜索引擎。（最后也没有做成，只做了旅游的垂直搜索） 我不知道其他人怎么想的，我自己觉得很兴奋。 我确实没有把握，也不知道怎么做，但当时就去学，就去看所有这些相关东西。 我觉得最后也许不一定做成，或者没有完全做到，但这个过程也会很有帮助： 只要你对事情的不确定性保持乐观，你会更愿意去尝试。 ","date":"2024-09-10","objectID":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/:3:2","tags":null,"title":"张一鸣：Stay hungry, Stay Young","uri":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/"},{"categories":["好文分享"],"content":"第三，不甘于平庸 有很多同学，已经非常优秀了。 但我想说，其实走向社会后，应该再设定更高的标准。 我见到很多大学期间的同学、一起共事的同事中，有很多非常不错的人才，技术、成绩都比我好。 但10年过去，很多人没有达到我的预期：我觉得他应该能做得很好，但他却没有做到。 很多人毕业后，目标设定就不高了。 我回顾了一下，发现有同事加入银行IT部门：有的是毕业后就加入，有的是工作一段时间后加入。 为什么我把这个跟“不甘于平庸”挂在一起呢？ 因为他们很多人加入，是为了快点解决户口，或者当时有些机构有分房补助，可以购买经济适用房。 后来我就在想一个问题，如果自己不甘于平庸，希望做得非常好的话，其实不会为这些东西担心：是否有北京户口，是否能买上一套经济适用房？ 如果一个人一毕业，就把目标定在这儿：在北京市五环内买一个小两居、小三居，把精力都花在这上面，那么工作就会受到很大影响。 他的行为会发生变化，不愿意冒风险。 比如我见到以前的朋友，他业余做一些兼职，获取一些收入。 那些兼职其实没有什么技术含量，而且对本职工作有影响，既影响他的职业发展，也影响他的精神状态。 我问他为什么，他说，哎，快点出钱付个首付。 我觉得他看起来是赚了，其实是亏的。 不甘于平庸很重要。 我说不平庸，并不是专门指薪酬要很高或者技术很好，而是你对自己的标准一定要高。 也许你前两年变化得慢，但10年后再看，肯定会非常不一样。 ","date":"2024-09-10","objectID":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/:3:3","tags":null,"title":"张一鸣：Stay hungry, Stay Young","uri":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/"},{"categories":["好文分享"],"content":"第四，不傲娇，要能延迟满足感 我在这里举个反例：两个我印象比较深刻的年轻人，素质、技术都蛮不错，也都挺有特点。 我当时是他们的主管，发现他们在工作中deliver的情况始终不好。 他们觉得其他同事比他们做得差，其实不是：他们确实可以算作在当时招的同事里面TOP 20%，但误以为自己是TOP 1%。 所以很多基础一点的工作； 比如要做一个调试工具，他就不愿意做； 或者需要跟同事配合的工作，他就配合得不好。 本来都是资质非常好的人才，人非常聪明、动手能力也强，但没有控制好自己的傲娇情绪。 我觉得这和“不甘于平庸”不矛盾。 “不甘于平庸”是你目标要设得很高，“不傲娇”是你对现状要踏实。 这2000个样本当中，我见到很多我原来觉得很好的，其实没有我想象中的发展好，我原来觉得不好的，其实超出我的预期。 ","date":"2024-09-10","objectID":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/:3:4","tags":null,"title":"张一鸣：Stay hungry, Stay Young","uri":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/"},{"categories":["好文分享"],"content":"第五，对重要的事情有判断力 选什么专业、选什么公司、选什么职业、选什么发展路径，自己要有判断力，不要被短期选择而左右。 上面一些例子，也都涵盖了这一点。 当时很多人愿意去外企，不愿意去新兴的公司。 06、07年，很多师弟、师妹问我职业选择，我都建议他们去百度，不要去IBM、微软。 但实际上，很多人都是出于短期考虑：外企可能名气大、薪酬高一点。 虽然这个道理，大家都听过很多遍，刚毕业时薪酬差三五千块，真的可以忽略不计。 短期薪酬差别并不重要。 但实际上，能摆脱这个、能有判断力的人，不是很多。 这些就是我想跟大家分享的，谢谢！ ","date":"2024-09-10","objectID":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/:3:5","tags":null,"title":"张一鸣：Stay hungry, Stay Young","uri":"/2024/09/10/%E5%BC%A0%E4%B8%80%E9%B8%A3stay-hungry-stay-young/"},{"categories":["今日份"],"content":"今天主动加了班，而且加的心情还不错。我真真切切的体会到用代码来解决问题是多么的酷。 我要从不同的地方，用相同的步骤拿到我想要的信息，这个事情要我来做，会耗费巨量的时间。而把它抽象成代码，用计算机来跑，不仅节省了现在的时间，还可以用在未来的场景，之后有相同的需求，直接复用就好。 最令我惊奇的点是，我居然没有养成这样的思维习惯：用代码，自动化的解决问题。 是我的同事提醒了我，我们不必依赖别人的工具，自己做一个就好了。 现在开始，把这个思维定在脑子里。 ","date":"2024-08-28","objectID":"/2024/08/28/2024-08-28-%E4%BB%A3%E7%A0%81/:0:0","tags":["纳瓦尔宝典"],"title":"代码和媒体是不需要许可就能使用的杠杆，你可以创建软件和媒体，让它们在你睡觉时为你工作。","uri":"/2024/08/28/2024-08-28-%E4%BB%A3%E7%A0%81/"},{"categories":["今日份","读书笔记"],"content":"明确值得解决的问题之后，要做什么呢？ 我们一开始可能有各种各样的设想，要做的事情多如牛毛，要学的东西数不胜数。但你的时间是有限的，必须抓住关键的几件事儿，做一个MVP出来，有一个demo可以演示、运转起来，之后再慢慢迭代。 明确了要服务的人群，值得解决的问题之后，就要开始行动起来了。 但，从哪里下手呢？ 在创业之初，极简主义创业者必须紧紧围绕真正关键的事情，而不是试图一下子什么都学、什么都做。 一开始，你并不需要什么都懂，即使是最成功的创始人一开始也什么都不知道，都是从零开始学习的。创业要的是兴趣，而不是技能，关注你知道的事情。如果你真心实意地想要解决问题，你就能够克服道路上一个一个的障碍。如果你下定决心服务客户，你就可以去学你需要知道的那些东西，然后将剩下的部分外包出去。只需要想清楚自己的哪些技能、知识和背景与头脑中的生意相符，并最大化地去利用这些优势。不需要征得他人的同意，直接开始行动。 ","date":"2024-08-26","objectID":"/2024/08/26/2024-08-26-mvp/:0:0","tags":["小而美"],"title":"MVP | 第三章 越少越好","uri":"/2024/08/26/2024-08-26-mvp/"},{"categories":["今日份","读书笔记"],"content":"从流程开始 将其他筹资以及软件的事情搁置一边，用你的时间和技能为客户解决真正的问题。 在你完成服务第一位顾客的周期的过程中，将过程的每一部分都记录下来，这样对每一位长期顾客，你都会有一本战术手册。这份文件将是你生意的真正MVP。我所说的并不是我们都在试图创建和推出的最小化可行产品(minimum viable product)，而是在它之前的有价值的人工流程(manual valuable process)，它将是你试图创建的生意的基础。 先用最破的办法去实践，验证真正的需求。 ","date":"2024-08-26","objectID":"/2024/08/26/2024-08-26-mvp/:1:0","tags":["小而美"],"title":"MVP | 第三章 越少越好","uri":"/2024/08/26/2024-08-26-mvp/"},{"categories":["今日份","读书笔记"],"content":"最后创建 ","date":"2024-08-26","objectID":"/2024/08/26/2024-08-26-mvp/:2:0","tags":["小而美"],"title":"MVP | 第三章 越少越好","uri":"/2024/08/26/2024-08-26-mvp/"},{"categories":["今日份"],"content":"最近《黑神话·悟空》这个游戏爆火，各种捷报、视频层出不穷，我也跃跃欲试，不过，还是没有买下来玩儿一玩儿。 不过，倒是让我想起了我大一、大二时候玩儿的《穿越火线》。 很多人也许听过，玩儿过这一款游戏，我基本是大一开始接触的，我菜的还可以。 游戏的目标是用枪把别人打死，一般有两种方法：直接对枪或者是偷袭。 让我对枪是不可能的，我打不过，我速度不够快，压枪也不行。于是，我总喜欢藏在角落，出其不意，有时候也颇具成效，最起码我杀了几个人。但大部分时候，尤其一些相对比较高端的局，我明明已经看到他了，准星也在他身上，也开枪了，但他的枪就是比我快一点。这究竟是为什么呢？ 我们宿舍刚好有这么一个大佬，可以一穿五那种。他告诉我要打提前枪，不管是对枪，还是防偷袭。 对枪的时候，整个地形图就那么大，人就那么几个，在转角处敌人可能出现的位置你先打他一两枪，发现打中了马上再连射，敌人就倒下了。还有偷袭，你清楚的知道敌人可能出现的点位，搜一搜，提前打两枪，他不就偷袭不成了吗？ 应用到其他场景，对于世界的不确定性，我们就是应该打提前枪，有鸟没鸟先搂他一梭子，关键得行动起来。打中了继续连射，打不中换一个点位，比没开枪的好。 ","date":"2024-08-25","objectID":"/2024/08/25/2024-08-25-%E6%8F%90%E5%89%8D%E6%9E%AA/:0:0","tags":null,"title":"提前枪","uri":"/2024/08/25/2024-08-25-%E6%8F%90%E5%89%8D%E6%9E%AA/"},{"categories":["今日份"],"content":"记录本身就是意义。 翻看自己 2 年前写的东西，我不仅惊叹于自己在某些方面的幼稚，也惊叹于自己当时的想法。这种感觉还挺奇妙的。 ","date":"2024-08-22","objectID":"/2024/08/22/2024-08-22-%E8%AE%B0%E5%BD%95%E5%B0%B1%E6%98%AF%E6%84%8F%E4%B9%89/:0:0","tags":null,"title":"记录就是意义","uri":"/2024/08/22/2024-08-22-%E8%AE%B0%E5%BD%95%E5%B0%B1%E6%98%AF%E6%84%8F%E4%B9%89/"},{"categories":["今日份"],"content":"很多人遇到问题，喜欢自己一个人琢磨，认为自己遇到的问题是独一无二的，只能靠自己一个人解决 实际上：99%的问题，都有标准答案，找个懂的人问问。——雷军 今天在想一个实现方案，其实业界已经有现成的了，这个时候你去研究现有的再结合自己的需求去做，不是更方便、快捷吗？ 很多时候，我们并不需要找到具体的那个人，只需要找到一本书、一篇文章就能找到解决方案。 假如你做一件事没有头绪，不妨看看别人成功实现的案例、沉淀下来的最佳实践。 你想成为想成为的人，不妨找到那个你想成为的人，看看他怎么做。 山姆商店创始人经常到竞争对手的店铺里闲逛，看看对方在做什么，产生了什么样的效果。站在竞争对手的肩膀上，学习对手，也不是不可以。 ","date":"2024-08-21","objectID":"/2024/08/21/2024-08-21-%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8A/:0:0","tags":["雷总"],"title":"站在巨人的肩膀上","uri":"/2024/08/21/2024-08-21-%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8A/"},{"categories":["今日份"],"content":"帕特南给我上的这堂筹资课伴随了我的整个职业生涯，使我在黑石募集了一笔又一笔基金。投资者一直在寻找极好的投资，你越是降低他们决策的难度，每个人获得的利益就越大。——《苏世民:我的经验与教训》 一次好的汇报其实就是在降低别人的决策难度。 仔细想一想，你研究了这件事，提出了解决方案，其他人一定有你懂吗？ 很多时候他们并不关注具体的逻辑细节，怎么实现的。 更加关注问题的背景是什么？你是为了实现什么目标做这个事，产生的结果是什么？结果能不能达成预期，有什么风险？ 汇报也是一个技术活儿。 ","date":"2024-08-20","objectID":"/2024/08/20/2024-08-20-%E6%B1%87%E6%8A%A5/:0:0","tags":["苏世民我的经验与教训"],"title":"汇报 | 降低决策难度 | 多做一些事情，实现对方的目标","uri":"/2024/08/20/2024-08-20-%E6%B1%87%E6%8A%A5/"},{"categories":["今日份","读书笔记"],"content":"一条简单的人生经验：如果在一个艰难的决定上意见不统一，你就应该选择短期内更痛苦的道路。前提条件是，两个选择利弊相当。 如果面对两个选择，利弊各占50%，你就应该选择短期内更艰难、更痛苦的道路。我们的大脑往往会选择摆脱短期痛苦，但要想获得长期收益，利用好复利效应，就得选择更痛苦的道路。 前几天刚好在公众号上读到这么一个故事： 前亚马逊员工李沐 22 年年底的时候想到两个用大语言模型（LLM）做生产力工具的想法。碰巧遇到张一鸣，就向他请教。讨论之后他反问：为什么不做 LLM 本身呢？他的下意识退缩：他们之前在 Amazon 的团队做了好几年这个，得上万张卡，和 blabla 这么一大堆困难。一鸣呵呵表示：这些都是短期困难，眼光得看长远点。 ","date":"2024-08-19","objectID":"/2024/08/19/2024-08-19-%E8%BF%8E%E9%9A%BE%E8%80%8C%E4%B8%8A/:0:0","tags":["纳瓦尔宝典"],"title":"迎难而上","uri":"/2024/08/19/2024-08-19-%E8%BF%8E%E9%9A%BE%E8%80%8C%E4%B8%8A/"},{"categories":["今日份"],"content":"施耐庵早已告诉了我们人生的去向，我们当然有选择的权利，按着自己的选择去追求一些方向。 但仔细分析下来——“母弱出商贾，父强做侍郎，族望留原籍，家贫走他乡”是有道理的，权衡之下，相比大多数人的选择也会是这样。 ","date":"2024-08-10","objectID":"/2024/08/10/2024-08-10-%E4%BA%BA%E7%94%9F%E7%9A%84%E5%8E%BB%E5%90%91/:0:0","tags":null,"title":"施耐庵早已告诉了我们人生的去向","uri":"/2024/08/10/2024-08-10-%E4%BA%BA%E7%94%9F%E7%9A%84%E5%8E%BB%E5%90%91/"},{"categories":["读书笔记","编程笔记"],"content":"数据类型设计基本原则 更小的通常更好 一般来说，尽量使用能够正确存储和表示数据的最小数据类型。 更小的数据类型更快，因为他们占用的磁盘、内存和CPU缓存的空间更少，处理时需要的CPU周期也更少。 不过要注意不能超过范围，在表中加数据类型范围是一个痛苦且耗时的操作。 简单为好 简单数据类型的操作通常需要更少的CPU周期。 例如，整型数据比字符型数据的比较操作代价更低，因为字符集和排序规则（collation）使字符型数据的比较更复杂。 存储图片数据不直接存储在MySQL数据库当中，而是在对象存储当中，数据库字段当中只存储图片地址 应该将日期和时间存储为MySQL的内置类型而不是字符串类型 应该用整型数据存储IP地址。 尽量避免存储NULL 通常情况下最好指定列为NOT NULL，除非明确需要存储NULL值。 为什么呢？ 如果查询中包含可为NULL的列对于MySQL来说更难优化。因为可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。 通常把可为NULL的列改为NOT NULL带来的性能提升比较小，所以（调优时）没有必要首先在现有schema中查找并修改这种情况，除非确定这会导致问题。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:1:0","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"选择数据类型步骤 第一步需要确定合适的大类型：数字、字符串、时间等 第二步是选择具体类型 关注存储的值范围、表示的精度或者需要的物理空间（磁盘和内存）上存在着差异。 步骤1：确定数据的大类 数值类型、字符串类型、日期和时间类型、二进制类型等 步骤2：选择具体数据类型 值范围：考虑数据可能的最小值和最大值。例如，如果你需要存储年龄，可以选择TINYINT，但如果是存储较大数值，可能需要INT或BIGINT。 精度：对于浮点数和小数，考虑所需的精度。FLOAT或DOUBLE适用于浮点数，而DECIMAL适用于需要固定小数点的场合。 物理空间：估算数据占用的磁盘和内存空间。例如，VARCHAR和TEXT类型可以存储相同类型的数据，但VARCHAR可以指定最大长度，可能更节省空间。 性能：数据类型的选择也会影响数据库的性能。通常，更小的数据类型会有更好的性能，因为它们占用更少的磁盘、内存和处理时间。 特定功能：某些数据类型支持特定的数据库功能，如全文索引或空间数据处理。 其他考虑因素 索引：如果某列会被频繁用作索引，选择合适的数据类型可以提高索引效率。 默认值：考虑是否需要为字段设置默认值。 允许的空值：确定字段是否可以接受NULL值。 字符集和排序规则：对于字符串类型，需要考虑字符集和排序规则，特别是在处理多语言数据时。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:2:0","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"MySQL 数据库数据类型 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:3:0","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"整数类型 数字类型：整数（whole number）和实数（real number，带有小数部分的数字） 整数类型：TINYINT、SMALLINT、MEDIUMINT、INT或BIGINT。它们分别使用8、16、24、32和64位存储空间。可以存储的值的范围从-2（N-1）到2（N-1）-1，其中N是存储空间的位数。 整数类型有可选的UNSIGNED属性，表示不允许负值，这大致可以使正数的上限提高一倍。 有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据数据实际范围选择合适的类型。 整数计算通常使用64位的BIGINT整数。（一些聚合函数是例外，它们使用DECIMAL或DOUBLE进行计算。） MySQL可以为整数类型指定宽度，例如，INT（11），这对大多数应用毫无意义：它不会限制值的合法范围，只是规定了MySQL的一些交互工具（例如，MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT（1）和INT（20）是相同的。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:3:1","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"实数类型 实数是带有小数部分的数字。 MySQL既支持精确类型，也支持不精确类型。 FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。 浮点类型通常比DECIMAL使用更少的空间来存储相同范围的值。FLOAT列使用4字节的存储空间。DOUBLE占用8字节，比FLOAT具有更高的精度和更大的值范围。 应该使用可以满足需求的最小精度， ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:3:2","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"字符串类型 VARCHAR和CHAR类型选用 不同引擎中这两种类型存储可能不同 InnoDB VARCHAR：可以存储可变长字符串类型。比固定长度更省空间，仅仅使用必要的空间没有空值。 VARCHAR需要额外使用1或2字节记录字符串的长度 假设采用latin1字符集，一个VARCHAR（10）的列需要11字节的存储空间。VARCHAR（1000）的列则需要1002个字节，因为需要2字节存储长度信息。 缺点：行是可变长的，在更新的时候行会增长，这会导致额外的问题。InnoDB可能需要分割页面来容纳行。 应用场景：字符串列的最大长度远大于平均长度；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。 CHAR CHAR是固定长度的，要为字符串分配足够的空间 当存储CHAR值时，MySQL删除所有尾随空格。如果需要进行比较，值会用空格填充。 应用： CHAR适合存储非常短的字符串，或者适用于所有值的长度都几乎相同的情况。 例如，对于用户密码的MD5值，CHAR是一个很好的选择，它们的长度总是相同的 更新频繁的数据用CHAR也更好，因为固定长度不容易出现内存碎片。 但是CHAR类型末尾存空格的时候会被自动去掉 与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，它们存储的是二进制字符串。二进制字符串与常规字符串非常相似，但它们存储的是字节而不是字符。 VARCHAR（5）和VARCHAR（200）哪个更好？ 使用VARCHAR（5）和VARCHAR（200）存储’hello’的空间开销是一样的 较大的列会使用更多的内存，因为MySQL通常会在内部分配固定大小的内存块来保存值，分配更大的内存会对内存临时表的排序和操作造成影响。 最好的策略是只分配真正需要的空间。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:3:3","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"BLOB和TEXT类型 用来存储很大数据字符串类型。 BLOB采用二进制方式；TEXT采用字符方式。 字符类型是TINYTEXT、SMALLTEXT、TEXT、MEDIUMTEXT和LONGTEXT； 二进制类型是TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。 BLOB是SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词。 存储引擎通常会专门存储它们。当BLOB和TEXT值太大时，InnoDB会使用独立的“外部”存储区域，此时每个值在行内需要1～4字节的存储空间，然后在外部存储区域需要足够的空间来存储实际的值。 BLOB和TEXT家族之间的唯一区别是，BLOB类型存储的是二进制数据，没有排序规则或字符集，但TEXT类型有字符集和排序规则。 MySQL不能将BLOB和TEXT数据类型的完整字符串放入索引，也不能使用索引进行排序。 在数据库中存储图像？ 把图像以BLOB类型存储在数据库中，随着数据大小的增长，修改表的操作会由于BLOB数据的大小而变得越来越慢。 最好把它存在对象存储中，比如OSS、COS ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:3:4","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"使用枚举代替字符串类型 有时可以使用ENUM（枚举）列代替常规的字符串类型。 MySQL在存储枚举时非常紧凑 CREATE TABLE enum test( e ENUM('fish', 'apple', 'dog') NOT NULL INSERT INTO enum_test(e) VALUES('fish'),('dog'),('apple'); 上面三行实际上存储的是整数，而不是字符串 如果使用数字作为ENUM常量，这种双重属性很容易导致混乱，例如，ENUM（‘1’，‘2’，‘3’）。尽量避免这么做。 ENUM字段是根据内部整数值排序的，而不是根据字符串本身： 在查询中使用FIELD()函数显式地指定排序顺序，但这会导致MySQL无法利用索引消除排序： MySQL将每个枚举值存储为整数，并且必须进行查找以将其转换为字符串表示，因此ENUM列有一些开销。这些开销通常可以被ENUM列的小尺寸所抵消，但并不总是如此。特别是，将CHAR/VARCHAR列联接到ENUM列可能比联接到另一个CHAR/VARCHAR列更慢。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:3:5","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"日期和时间类型 MySQL可以存储的最小时间粒度是微秒。 MySQL提供了DATETIME和TIMESTAMP存储时间 DATETIME 可以保存大范围的数值，从1000年到9999年，精度为1微秒。它以YYYYMMDDHHMMSS格式存储压缩成整数的日期和时间，且与时区无关。这需要8字节的存储空间。 默认情况下，MySQL以可排序、无歧义的格式显示DATETIME值，例如，2008-01-16 22：37：08。这是ANSI表示日期和时间的标准方式。 TIMESTAMP TIMESTAMP类型存储自1970年1月1日格林尼治标准时间（GMT）午夜以来经过的秒数——与UNIX时间戳相同。TIMESTAMP只使用4字节的存储空间，所以它的范围比DATETIME小得多：只能表示从1970年到2038年1月19日 MySQL提供FROM_UNIXTIME()函数来将UNIX时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数将日期转换为UNIX时间戳。 时间戳显示的值依赖于时区。MySQL服务器、操作系统和客户端连接都有时区设置。 没有指定的时候，TIMESTAMP列的值，MySQL默认也会将该列的值更新为当前时间。 TIMESTAMP列在默认情况下为NOT NULL 将日期和时间存储为整数？ 通过将日期和时间存储为UNIX纪元（即自1970年1月1日以来的秒数），以协调世界时（UTC）的形式，可避免MySQL处理的复杂性，这一做法越来越流行。使用带符号的32位INT，可以表达直到2038年的时间。使用无符号的32位INT，可以表达直到2106年的时间。如果使用64位，还可以超出这些范围。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:3:6","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"位压缩数据类型 所有这些位压缩类型，不管底层存储和处理方式如何，从技术上来说都是字符串类型。 BIT 可以使用BIT列存储一个或多个true/false值。BIT（1）定义一个包含1位的字段，BIT（2）存储2位的字段，依此类推；BIT列的最大长度为64位。InnoDB将每一列存储为足够容纳这些位的最小整数类型，所以使用BIT列不会节省任何存储空间。 建议谨慎使用BIT类型。对于大多数应用来说，最好避免使用这种类型。 除非你非常注重节省空间，否则我们仍然建议使用TINYINT。 SET 如果需要存储多个true/false值，可以考虑使用MySQL原生的SET数据类型，可以将多列组合成一列，这在MySQL内部是以一组打包的位的集合来表示的。这样可以更有效地利用存储空间，MySQL具有FIND_IN_SET()和FIELD()等函数，使其易于在查询中使用。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:3:7","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"选择标识符（主键） 每个表都要设置主键，标识符是引用行及通常使其唯一的方式。 选择类型之后要在相关表中使用相同的类型。包括UNSIGNED等属性 混合不同的数据类型可能会导致性能问题；隐式类型转换可能会出现难以发现的错误 选择最小数据类型。 整数类型 整数通常是标识符的最佳选择，因为它们速度快，并且可以自动递增。AUTO_INCREMENT是一个列属性，可以为新的行自动生成一个整数类型的值。 字符串类型 如果可能，应避免使用字符串类型作为标识符的数据类型，因为它们很消耗空间，而且通常比整数类型慢。 对于完全“随机”的字符串要非常小心，如MD5()、SHA1()或UUID()生成的字符串。这些函数生成的新值会任意分布在很大的空间内，这会减慢INSERT和某些类型的SELECT查询的速度 因为插入的值会写到索引的随机位置，所以会使得INSERT查询变慢。这会导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。 SELECT查询也会变慢，因为逻辑上相邻的行会广泛分布在磁盘和内存中。 对于所有类型的查询，随机值都会导致缓存的性能低下，因为它们会破坏引用的局部性，而这正是缓存的工作原理。如果整个数据集都是“热的”，那么将任何特定部分的数据缓存到内存中都没有任何好处，而且如果工作集比内存大，缓存就会出现大量刷新和不命中。 如果存储通用唯一标识符（UUID）值，则应该删除破折号，或者更好的做法是，使用UNHEX()函数将UUID值转换为16字节的数字，并将其存储在一个BINARY（16）列中。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:3:8","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"特殊数据类型 应该将IP地址存储为无符号整数。MySQL提供了INET_ATON()和INET_NTOA()函数来在这两种表示形式之间进行转换 使用的空间从VARCHAR（15）的约16字节缩减到无符号32位整数的4字节。如果你担心数据库的可读性，不想继续使用函数查看行数据，请记住MySQL有视图，可以使用视图来简化数据查看的复杂性。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:3:9","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"MySQL schema设计中的陷阱 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:4:0","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"太多的列 MySQL的存储引擎API通过在服务器和存储引擎之间以行缓冲区格式复制行来工作 InnoDB的行格式总是需要转换的。这种转换的成本取决于列数。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:4:1","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"太多的联接 即使联接数远小于61，规划和优化查询的成本对MySQL来说也会成为问题。一个粗略的经验法则是，如果需要以高并发性快速执行查询，那么每个查询最好少于十几个的表。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:4:2","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"NULL不是虚拟值 即使需要在表中存储事实上的“空值”，也可能不需要使用NULL。也许可以使用0、特殊值或空字符串作为代替。 但是遵循这个原则也不要走极端。当需要表示未知值时，不要太害怕使用NULL。在某些情况下，使用NULL比使用某个虚拟常数更好。 例如使用-1表示一个未知的整数，可能会使代码复杂化，容易引入bug，并通常会把事情搞得一团糟。处理NULL并不容易，但通常比其他替代方案更好。 ","date":"2024-02-26","objectID":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/:4:3","tags":["MySQL"],"title":"高性能MySQL-高性能MySQL-schema设计与管理","uri":"/2024/02/26/%E9%AB%98%E6%80%A7%E8%83%BDmysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["读书笔记","编程笔记"],"content":"要实现高效的查询，查询优化、索引优化、库表结构优化需要齐头并进。 本文主要围绕查询性能的优化 ","date":"2024-02-09","objectID":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/:0:0","tags":["MySQL"],"title":"高性能MySQL-MySQL查询优化","uri":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},{"categories":["读书笔记","编程笔记"],"content":"为什么查询的速度会慢？ 关键在于响应时间。 执行一个任务，可能这个任务由一系列的任务组成，只要优化它其中的子任务，让子任务运行的快，或者直接消除子任务，就能让整个响应时间快起来。在查询的整个过程中，从客户端到服务器，然后在服务器上进行语法解析，生成执行计划之后执行，再返回到客户端，要经过复杂的历程。 在完成这些任务的时候，查询需要在不同的地方花费时间： 包括网络 CPU计算 生成统计信息和执行计划 锁等待（互斥等待）等操作 尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。 优化查询的目的就是，减少和消除一些不必要的操作、消除重复了很多次的操作、优化某些执行太慢的操作。 ","date":"2024-02-09","objectID":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/:1:0","tags":["MySQL"],"title":"高性能MySQL-MySQL查询优化","uri":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},{"categories":["读书笔记","编程笔记"],"content":"优化查询排查的基本步骤 ","date":"2024-02-09","objectID":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/:2:0","tags":["MySQL"],"title":"高性能MySQL-MySQL查询优化","uri":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},{"categories":["读书笔记","编程笔记"],"content":"1. 不访问不必要的数据 确认应用程序是否在检索大量且不必要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。 确认MySQL服务器层是否在分析大量不需要的数据行。 向数据库请求了不需要的数据 有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销，另外，这也会消耗应用服务器的CPU和内存资源。 查询了不需要的记录 一个常见的错误是，常常会误以为MySQL只会返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。 例如，在新闻网站中取出100条记录，但是只是在页面上显示前面10条。有人会误以为MySQL执行查询只返回他们需要的10条数据，然后停止查询，实际情况是，MySQL会查询出全部的结果，然后客户端应用程序接收后再抛弃其中大部分数据。 解决方案：在这样的查询后面加上LIMIT子句 多表联接时返回全部列 这将返回这三个表的全部数据列 正确的方式应该是像下面这样只取需要的列： 总是取出全部列 每次看到SELECT *的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的列，很可能不是必需的 使用 SELECT * 的缺点 取出全部列，会让优化器无法完成索引覆盖扫描这类优化 给服务器带来额外的I/O、内存和CPU的消耗 当然，查询返回超过需要的数据也不总是坏事 这种方式可以简化开发，能够提高相同代码片段的复用性。如果清楚这样做对性能的影响，那么这种做法也是值得考虑的 重复查询相同的数据 例如，在用户评论的地方需要查询用户头像的URL，那么在用户多次评论的时候，可能就会反复查询这个数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出 ","date":"2024-02-09","objectID":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/:2:1","tags":["MySQL"],"title":"高性能MySQL-MySQL查询优化","uri":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},{"categories":["读书笔记","编程笔记"],"content":"2. MySQL是否在扫描额外的记录 对于MySQL，最简单的衡量查询开销的三个指标如下： 响应时间 扫描的行数 返回的行数 检查慢日志记录是找出扫描行数过多的查询的好办法。 响应时间 响应时间是两部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等I/O操作完成，也可能是等待行锁。遗憾的是，我们无法把响应时间细分到上面这些部分 当你看到一个查询的响应时间时，首先需要问问自己，这个响应时间是否是一个合理的值。实际上可以使用“快速上限估计”法来估算查询的响应时间 这是在Tapio Lahdenmaki和Mike Leach编写的Relational Database Index Design and the Optimizers（Wiley出版社出版）一书中提到的技术 概括地说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机I/O，再用其乘以在具体硬件条件下一次I/O的消耗时间。最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值。 扫描的行数和返回的行数 查看该查询扫描的行数是非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。 扫描的行数和访问类型 有些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无须扫描就能返回结果。 EXPLAIN语句中的type列反映了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列出的这些，速度从慢到快，扫描的行数从多到少 如果你没办法找到合适的访问类型，那么最好的解决办法通常就是增加一个合适的索引 一般地，MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为： 在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的 所以where条件后面的字段一定要加索引 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。 从整个索引树中拿到想要的记录 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using where）。这在MySQL服务器层完成，MySQL需要先从数据表中读出记录然后过滤。 如果发现查询需要扫描大量的数据但只返回少数行，那么通常可以尝试下面的技巧去优化它： 使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了 改变库表结构。例如，使用单独的汇总表 重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询 ","date":"2024-02-09","objectID":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/:2:2","tags":["MySQL"],"title":"高性能MySQL-MySQL查询优化","uri":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},{"categories":["读书笔记","编程笔记"],"content":"3. 重构查询 将查询转换为返回相同结果的等价形式，以获得更好的性能 一个复杂查询还是多个简单查询 设计查询的时候，一个需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。 在其他条件都相同的时候，使用尽可能少的查询当然是更好的。但是有时候，将一个大查询分解为多个小查询是很有必要的。 别害怕这样做，好好衡量一下这样做是不是会减少工作量 不过，在设计应用的时候，一个查询可以做的事情，就不要把这个查询设计成多个。 我们看到有些应用对一个数据表做10次独立的查询来返回10行数据，每个查询返回一条结果，查询10次，这时可以使用单个查询获取10行数据。有的应用甚至每次只查询一个字段，获取一行数据就需要执行多次查询。 将大查询切分成小查询 例子：删除旧的数据 定期清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大的DELETE语句切分成多个较小的查询可以尽可能小地影响MySQL的性能，同时还可以降低MySQL复制的延迟 一次删除一万行数据一般来说是一个比较高效而且对服务器[插图]影响最小的做法（如果是事务型引擎，很多时候小事务能够更高效） 如果每次删除数据后，都暂停一会儿再做下一次删除，也可以将服务器上原本一次性的压力分散到一个很长的时间段中，可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。 干掉连接查询 join 高性能的应用都会对联接查询进行分解 简单地说，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行联接 例如，下面这个查询 可以分解成下面这些查询来代替： 用分解联接查询的方式重构查询有如下优势： 让缓存的效率更高 许多应用程序可以方便地缓存单表查询对应的结果对象 例如，上面查询中的tag mysql已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了ID为123、567、9098的内容，那么第三个查询的IN()中就可以少几个ID。 将查询分解后，执行单个查询可以减少锁的竞争。 在应用层做联接，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。 查询本身的效率也可能会有所提升 在这个例子中，使用IN()代替联接查询，可以让MySQL按照ID顺序进行查询，这可能比随机的联接要更高效。 可以减少对冗余记录的访问 在应用层做联接查询，意味着对于某条记录应用只需要查询一次，而在数据库中做联接查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。 在有些场景下，在应用程序中执行联接操作会更加有效 当可以缓存和重用之前查询结果中的数据时 当在多台服务器上分发数据时 当能够使用IN()列表替代联接查询大型表时 当一次联接查询中多次引用同一张表时 下面的解释由AI生成 当可以缓存和重用之前查询结果中的数据时：在某些情况下，你可能会在查询中重复使用某个子查询的结果。在这种情况下，联接查询可以帮助你避免重复查询数据库。例如： SELECT a.name, b.address FROM (SELECT id, name FROM users WHERE age \u003e 20) a JOIN (SELECT user_id, address FROM addresses WHERE city = '北京') b ON a.id = b.user_id; 在这个例子中，我们在子查询中获取了所有年龄大于20岁的用户和住在北京的地址，然后将这两个子查询的结果进行联接。 当在多台服务器上分发数据时：当你的数据被分布在多台服务器上时，你可能需要通过联接查询来获取你需要的数据。例如，你的用户数据和订单数据可能被存储在不同的服务器上，你可以通过联接查询来获取用户的订单信息。 当能够使用IN()列表替代联接查询大型表时：在某些情况下，使用IN()列表可能会比联接大型表更高效。例如，如果你只需要从大型表中获取少量数据，你可以先从小表中获取这些数据的ID，然后再使用IN()列表来查询大表。例如： SELECT * FROM big_table WHERE id IN (SELECT id FROM small_table WHERE condition); 当一次联接查询中多次引用同一张表时：在某些情况下，你可能需要在同一次查询中多次引用同一张表。在这种情况下，联接查询可以帮助你更方便地获取你需要的数据。例如，你可能需要获取用户的订单信息和地址信息，这两个信息可能都存储在同一张表中，你可以通过联接查询来获取这些信息。例如： SELECT a.name, b.order, c.address FROM users a JOIN orders b ON a.id = b.user_id JOIN addresses c ON a.id = c.user_id; ","date":"2024-02-09","objectID":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/:2:3","tags":["MySQL"],"title":"高性能MySQL-MySQL查询优化","uri":"/2024/02/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},{"categories":["编程笔记"],"content":"GET 使用 Query，请求中参数直接拼接在 url 中 http://localhost:8888/v1/user/get?id=9 router userv1.GET(\"/get\", userHandler.Get) 参数绑定 idParam := c.Query(\"id\") ","date":"2024-01-29","objectID":"/2024/01/29/gin-params/:1:0","tags":["Gin"],"title":"Gin 框架获取请求参数的方式","uri":"/2024/01/29/gin-params/"},{"categories":["编程笔记"],"content":"POST-JSON var req entity.User if err := c.ShouldBindJSON(\u0026req); err != nil { response.Failed(c, code.ErrBind, err.Error()) return } 绑定方式有两种，Gin 官方文档是这么描述的： Gin提供了两类绑定方法： Type - Must bind Methods - Bind, BindJSON, BindXML, BindQuery, BindYAML Behavior - 这些方法属于 MustBindWith 的具体调用。 如果发生绑定错误，则请求终止，并触发 c.AbortWithError(400, err).SetType(ErrorTypeBind)。响应状态码被设置为 400 并且 Content-Type 被设置为 text/plain; charset=utf-8。 如果您在此之后尝试设置响应状态码，Gin会输出日志 [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422。 如果您希望更好地控制绑定，考虑使用 ShouldBind 等效方法。 Type - Should bind Methods - ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML Behavior - 这些方法属于 ShouldBindWith 的具体调用。 如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。 使用 Bind 方法时，Gin 会尝试根据 Content-Type 推断如何绑定。 如果你明确知道要绑定什么，可以使用 MustBindWith 或 ShouldBindWith。**** ","date":"2024-01-29","objectID":"/2024/01/29/gin-params/:2:0","tags":["Gin"],"title":"Gin 框架获取请求参数的方式","uri":"/2024/01/29/gin-params/"},{"categories":["编程笔记"],"content":"URL参数 // 使用URL参数并获取参数 router.GET(\"/user/:username/:password\", func(c *gin.Context) { // 使用Param获取URL参数 username := c.Param(\"username\") password := c.Param(\"password\") // 返回请求参数 c.JSON(200, gin.H{ \"username\": username, \"password\": password, }) }) ","date":"2024-01-29","objectID":"/2024/01/29/gin-params/:3:0","tags":["Gin"],"title":"Gin 框架获取请求参数的方式","uri":"/2024/01/29/gin-params/"},{"categories":["技术"],"content":"github 官方文档 ","date":"2024-01-29","objectID":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/:0:0","tags":["搜索"],"title":"github 搜索技巧","uri":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"categories":["技术"],"content":"常用搜索语法 ","date":"2024-01-29","objectID":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/:1:0","tags":["搜索"],"title":"github 搜索技巧","uri":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"categories":["技术"],"content":"in 限定搜索范围 可以限定范围去找 github 仓库 限定符 示例 in:name jquery in:name 匹配名称中带有“jquery”的存储库。 in:description jquery in:name,description 匹配名称或说明中带有“jquery”的存储库。 in:topics jquery in:topics 将带“jquery”标签的存储库匹配为主题。 in:readme jquery in:readme 匹配自述文件中提及“jquery”的存储库。 repo:owner/name repo:octocat/hello-world 匹配特定的存储库名称。 ","date":"2024-01-29","objectID":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/:1:1","tags":["搜索"],"title":"github 搜索技巧","uri":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"categories":["技术"],"content":"按照仓库创建或者上次更新时间搜素 找到当前活跃的仓库 限定符 示例 created:\u003c*YYYY-MM-DD* webos created:\u003c2011-01-01 匹配具有 2011 年之前创建的“webos”一词的存储库。 pushed:\u003e*YYYY-MM-DD* css pushed:\u003e2013-02-01 匹配具有在 2013 年 1 月之后推送到其中的“css”一词的存储库。 pushed:\u003e=*YYYY-MM-DD* fork:only case pushed:\u003e=2013-03-06 fork:only 匹配在 2013 年 3 月 6 日或之后将“case”一词推送到其中的存储库（即分支）。 ","date":"2024-01-29","objectID":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/:1:2","tags":["搜索"],"title":"github 搜索技巧","uri":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"categories":["技术"],"content":"按照语言搜索 搜索特定的编程语言 限定符 示例 language:*LANGUAGE* rails language:javascript 匹配具有以 JavaScript 编写的“rails”一词的存储库。 ","date":"2024-01-29","objectID":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/:1:3","tags":["搜索"],"title":"github 搜索技巧","uri":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"categories":["技术"],"content":"组合搜索 比如说我现在要寻找 api 开放平台 ","date":"2024-01-29","objectID":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/:2:0","tags":["搜索"],"title":"github 搜索技巧","uri":"/2024/01/29/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"categories":["English Daily"],"content":" implementation intention Implementation intention , which is a plan you make beforehand about when and where to act. Broadly speaking, the format for creating an implementation intention is: “When situation X arises, I will perform response Y.” eg. Writing down the exact time to read books. When the moment of action occurs, there is no need to make a decision. Simply follow your predetermined plan. The simple way to apply this strategy to your habits is to fill out this sentence: I will [BEHAVIOR] at [TIME] in [LOCATION]. If you aren’t sure when to start your habit, try the first day of the week,month, or year habit stacking ","date":"2024-01-23","objectID":"/2024/01/23/day09-atomic-habits/:0:0","tags":["Atomic Habits"],"title":"day09 The Best Way to Start a New Habit","uri":"/2024/01/23/day09-atomic-habits/"},{"categories":["English Daily"],"content":"With enough practice, your brain will pick up on the cues that predict certain outcomes without consciously thinking about it.This is what makes habits useful. It’s also what makes them dangerous. As habits form, your actions come under the direction of your automatic and nonconscious mind. You fall into old patterns before you realize what’s happening Solution Always be aware of your bad habits. Before you engage in these habits, say out loud, ‘What am I about to do and what will be the consequences? That’s the origin of the Habits Scorecard, which is a simple exercise you can use to become more aware of your behavior. create your own, make a list of your daily habits. Wake up Turn off alarm Check my phone Go to the bathroom Weigh myself Take a shower Brush my teeth write “+”, write “–” or write “=” Once you have a full list, look at each behavior, and ask yourself, “Is this a good habit, a bad habit, or a neutral habit?” If it is a good habit, write “+” next to it. If it is a bad habit, write “–”. If it is a neutral habit, write “=”. The marks you give to a particular habit will depend on your situation and your goals. There are no good habits or bad habits. There are only effective habits. That is,effective at solving problems Smoking a cigarette may reduce stress right now (that’s how it’s serving you), but it’s not a healthy long-term behavior. Ask yourself questions. Does this behavior help me become the type of person I wish to be? Does this habit cast a vote for or against my desired identity?” ","date":"2024-01-22","objectID":"/2024/01/22/day08-atomic-habits/:0:0","tags":["Atomic Habits"],"title":"day08 Be aware of your habits and actions, then point it","uri":"/2024/01/22/day08-atomic-habits/"},{"categories":["English Daily"],"content":"A habit is a behavior that has been repeated enough times to become automatic. The ultimate purpose of habits is to solve the problems of life with as little energy and effort as possible. Any habit can be broken down into a feedback loop that involves four steps: cue, craving, response, and reward. The Four Laws of Behavior Change are a simple set of rules we can use to build better habits. They are (1) make it obvious, (2) make it attractive, (3) make it easy, and (4) make it satisfying. ","date":"2024-01-20","objectID":"/2024/01/20/day07-atomic-habits-summary/:0:0","tags":["Atomic Habits"],"title":"day07 Chapter 3 Summary","uri":"/2024/01/20/day07-atomic-habits-summary/"},{"categories":["English Daily"],"content":"we need to transform these four steps into a practical framework that we can use to design good habits and eliminate bad ones. ","date":"2024-01-20","objectID":"/2024/01/20/day07-atomic-habits/:0:0","tags":["Atomic Habits"],"title":"day07 Use four steps to design habits","uri":"/2024/01/20/day07-atomic-habits/"},{"categories":["English Daily"],"content":"How to Create a Good Habit The 1st law (Cue): Make it obvious. The 2nd law (Craving): Make it attractive. The 3rd law (Response): Make it easy. The 4th law (Reward): Make it satisfying. ","date":"2024-01-20","objectID":"/2024/01/20/day07-atomic-habits/:1:0","tags":["Atomic Habits"],"title":"day07 Use four steps to design habits","uri":"/2024/01/20/day07-atomic-habits/"},{"categories":["English Daily"],"content":"How to Break a Bad Habit Inversion of the 1st law (Cue): Make it invisible. Inversion of the 2nd law (Craving): Make it unattractive. Inversion of the 3rd law (Response): Make it difficult. Inversion of the 4th law (Reward): Make it unsatisfying. ","date":"2024-01-20","objectID":"/2024/01/20/day07-atomic-habits/:2:0","tags":["Atomic Habits"],"title":"day07 Use four steps to design habits","uri":"/2024/01/20/day07-atomic-habits/"},{"categories":["English Daily"],"content":"WHY YOUR BRAIN BUILDS HABITS A habit is a behavior that has been repeated enough times to become automatic. There is the feedback loop behind all human behavior: try, fail, learn, try differently THE HABIT LOOP cue-提示 craving-渴求 reward-反应 response-奖励 First, there is the cue. The cue triggers your brain to initiate a behavior. Our prehistoric ancestors were paying attention to cues that signaled the location of primary rewards like food, water, and sex. Today, we spend most of our time learning cues that predict secondary rewards like money and fame, power and status, praise and approval, love and friendship, or a sense of personal satisfaction. Cravings are the second step, and they are the motivational force behind every habit. The third step is the response. The response is the actual habit you perform, which can take the form of a thought or an action If a particular action requires more physical or mental effort than you are willing to expend, then you won’t do it Finally, the response delivers a reward. Rewards are the end goal of every habit. ​ Problem phase Cue: You wake up. Craving: You want to feel alert. Solution phase Response: You drink a cup of coffee. Reward: You satisfy your craving to feel alert. Drinking coffee becomes associated with waking up. ","date":"2024-01-19","objectID":"/2024/01/19/day06-atomic-habits-2/:0:0","tags":["Atomic Habits"],"title":"day06 4 Simple Steps to Build Better Habits","uri":"/2024/01/19/day06-atomic-habits-2/"},{"categories":["English Daily"],"content":"There are three levels of change: outcome change, process change,and identity change.The most effective way to change your habits is to focus not on what you want to achieve, but on who you wish to become. Your identity emerges out of your habits. Every action is a vote for the type of person you wish to become. Becoming the best version of yourself requires you to continuously edit your beliefs, and to upgrade and expand your identity. The real reason habits matter is not because they can get you better results (although they can do that), but because they can change your beliefs about yourself. ","date":"2024-01-19","objectID":"/2024/01/19/day06-atomic-habits/:0:0","tags":["Atomic Habits"],"title":"day06 Chapter 2 Summary","uri":"/2024/01/19/day06-atomic-habits/"},{"categories":["English Daily"],"content":"Habits are the compound interest of self-improvement. Getting 1 percent better every day counts for a lot in the long-run. Habits are a double-edged sword. They can work for you or against you, which is why understanding the details is essential. Small changes often appear to make no difference until you cross a critical threshold.The most powerful outcomes of any compounding process are delayed. You need to be patient. An atomic habit is a little habit that is part of a larger system. Just as atoms are the building blocks of molecules, atomic habits are the building blocks of remarkable results. If you want better results, then forget about setting goals. Focus on your system instead. You do not rise to the level of your goals. You fall to the level of your systems. ","date":"2024-01-18","objectID":"/2024/01/18/day05-atomic-habits/:0:0","tags":["Atomic Habits"],"title":"day05 Chapter 1 Summary","uri":"/2024/01/18/day05-atomic-habits/"},{"categories":["English Daily"],"content":"THREE LAYERS OF BEHAVIOR CHANGE 结果：The first layer is changing your outcome. — losing weight, publishing a book, winning a championship. 行动：The second layer is changing your process. — developing a meditation practice 角色：The third and deepest layer is changing your identity. — your worldview, your self-image Outcomes are about what you get. Processes are about what you do. Identity is about what you believe The Story Imagine two people resisting a cigarette. When offered a smoke, the first person says, “No thanks. I’m trying to quit.” It sounds like a reasonable response, but this person still believes they are a smoker who is trying to be something else. They are hoping their behavior will change while carrying around the same beliefs. The second person declines by saying, “No thanks. I’m not a smoker.”It’s a small difference, but this statement signals a shift in identity. Smoking was part of their former life, not their current one. They no longer identify as someone who smokes. When you have repeated a story to yourself for years, it is easy to slide into these mental grooves and accept them as a fact. The goal is not to read a book, the goal is to become a reader. The goal is not to run a marathon, the goal is to become a runner. The goal is not to learn an instrument, the goal is to become a musician. THE TWO-STEP PROCESS TO CHANGING YOUR IDENTITY Decide the type of person you want to be. Prove it to yourself with small wins. The most practical way to change who you are is to change what you do. ","date":"2024-01-18","objectID":"/2024/01/18/day05-atomic-habits-2/:0:0","tags":["Atomic Habits"],"title":"day05 The most importantly, What is your identity.","uri":"/2024/01/18/day05-atomic-habits-2/"},{"categories":["读书笔记","编程笔记"],"content":"我对自己的定位仍旧是一个后端工程师，学习了解 JavaScript 的原因是，我自己开发项目需要写一些前端。 就主打一个实用，能实现功能即可。 ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:0:0","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"第1章 什么是JavaScript ❑ JavaScript历史回顾 ❑ JavaScript是什么 ❑ JavaScript与ECMAScript的关系 ❑ JavaScript的不同版本 ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:1:0","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"历史 1995年，JavaScript问世。当时，它的主要用途是代替Perl等服务器端语言处理输入验证 它很简单，学会用只要几分钟；它又很复杂，掌握它要很多年。 Java 和 JavaScript 的关系 在Netscape Navigator 2正式发布前，网景把 LiveScript 改名为 JavaScript，以便搭上媒体当时热烈炒作Java的顺风车。 ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:1:1","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"JavaScript 是什么 完整的JavaScript实现包含以下几个部分 ❑ 核心（ECMAScript） ❑ 文档对象模型（DOM） ❑ 浏览器对象模型（BOM） ECMAScript ECMA-262将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言 宿主环境提供ECMAScript的基准实现和与环境自身交互必需的扩展 Web 浏览器是 ECMAScript 的宿主环境，服务端JavaScript平台Node.js也是宿主环境 不涉及浏览器的话，ECMA-262到底定义了什么？ ❑ 语法❑ 类型❑ 语句❑ 关键字❑ 保留字❑ 操作符❑ 全局对象 ECMAScript只是对实现这个规范描述的所有方面的一门语言的称呼 JavaScript实现了ECMAScript，而Adobe ActionScript同样也实现了ECMAScript。 DOM 文档对象模型（DOM, Document Object Model）是一个应用编程接口（API），用于在HTML中使用扩展的XML。 DOM将整个页面抽象为一组分层节点。HTML或XML页面的每个组成部分都是一种节点，包含不同的数据 \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eSample Page\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e Hello World! \u003c/p\u003e \u003c/body\u003e \u003c/html\u003e DOM 的作用 DOM通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用DOM API，可以轻松地删除、添加、替换、修改节点。 BOM 浏览器对象模型（BOM）API，用于支持访问和操作浏览器的窗口 使用BOM，开发者可以操控浏览器显示页面之外的部分。 BOM主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的扩展都归在BOM的范畴内。比如，下面就是这样一些扩展： ❑ 弹出新浏览器窗口的能力； ❑ 移动、缩放和关闭浏览器窗口的能力； ❑ 对cookie的支持； ❑ 其他自定义对象，如XMLHttpRequest和IE的ActiveXObject。 ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:1:2","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"小结 ❑ ECMAScript：由ECMA-262定义并提供核心功能。 ❑ 文档对象模型（DOM）：提供与网页内容交互的方法和接口。 ❑ 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。 ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:1:3","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"第2章 HTML中的JavaScript ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:2:0","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"第3章 语言基础-基于ES6 ECMA-262第5版（ES5）定义的ECMAScript，是目前为止实现得最为广泛（即受浏览器支持最好）的一个版本。 第6版（ES6）在浏览器中的实现（即受支持）程度次之。到2017年底，大多数主流浏览器几乎或全部实现了这一版的规范。 为此，本章接下来的内容==主要基于ECMAScript第6版==。 ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:3:0","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"语法 ECMAScript的语法很大程度上借鉴了C语言和其他类C语言，如Java和Perl。 区分大小写 ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写 变量test和变量Test是两个不同的变量 标识符 标识符，就是变量、函数、属性或函数参数的名称 规则 ❑ 第一个字符必须是一个字母、下划线（_）或美元符号（$）； ❑ 剩下的其他字符可以是字母、下划线、美元符号或数字。 按照惯例，ECMAScript标识符使用驼峰大小写形式 firstSecond myCar doSomethingImportant ⚠注意：关键字、保留字、true、false和null不能作为标识符 注释 // 单行注释 /＊ 这是多行 注释 ＊/ 严格模式 启用了严格模式，不规范写法会被处理，不安全活动将抛出错误 ECMAScript 5增加了严格模式（strict mode）的概念 对整个脚本启用严格模式，在脚本开头加上 \"use strict\"; 这是一个预处理指令 指定一个函数启用严格模式 function doSomething() { \"use strict\"; // 函数体 } 语句-推荐加分号 分号 ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾 let sum = a + b // 没有分号也有效，但不推荐 let diff = a - b; // 加分号有效，推荐 代码块 代码块由一个左花括号（{）标识开始，一个右花括号（}）标识结束 if (test) { test = false; console.log(test); } 关键字与保留字 ECMA-262第6版规定的所有关键字如下 break do in typeof case else instanceof var catch export new void class extends return while const finally super with continue for switch yield debugger function this default if throw delete import try 规范中也描述了一组未来的保留字 始终保留： enum 严格模式下保留： implements package public interface protected static let private 模块代码中保留： await 这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说，最好还是不要使用关键字和保留字作为标识符和属性名，以确保兼容过去和未来的ECMAScript版本。 ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:3:1","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"变量 ECMAScript变量是松散类型的，意思是变量可以用于保存任何类型的数据 不是强类型 有3个关键字可以声明变量：var、const和let。 其中，var在ECMAScript的所有版本中都可以使用，而const和let只能在ECMAScript 6及更晚的版本中使用。 var 关键字 var message; 这行代码定义了一个名为message的变量，可以用它保存任何类型的值。（不初始化的情况下，变量会保存一个特殊值undefined） var message = \"hi\"; 可以自动推断类型 随后，不仅可以改变保存的值，也可以改变值的类型： var message = \"hi\"; message=100; //合法，但不推荐 var声明作用域 关键的问题在于，使用var操作符定义的变量会成为包含它的函数的局部变量。 function test() { var message = \"hi\"; // 局部变量 } test(); console.log(message); // 出错！ 在函数内定义变量时省略var操作符，可以创建一个全局变量 function test() { message=\"hi\"; //全局变量 } test(); console.log(message); // \"hi\" ⚠注意 虽然可以通过省略var操作符定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。这是因为不能一下子断定省略var是不是有意而为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出ReferenceError。 定义多个变量 var message = \"hi\", found = false, age = 29; 插入换行和空格缩进并不是必需的，但这样有利于阅读理解。 var声明提升 使用这个关键字声明的变量会自动提升到函数作用域顶部： function foo() { console.log(age); var age = 26; } foo(); // undefined 之所以不会报错，是因为ECMAScript运行时把它看成等价于如下代码： function foo() { var age; console.log(age); age = 26; } foo(); // undefined 反复多次使用var声明同一个变量也没有问题： function foo() { var age = 16; var age = 26; var age = 36; console.log(age); } foo(); // 36 let声明 let跟var的作用差不多 最明显的区别是，let声明的范围是块作用域，而var声明的范围是函数作用域。 if (true) { var name = 'Matt'; console.log(name); // Matt } console.log(name); // Matt if (true) { let age = 26; console.log(age); // 26 } console.log(age); // ReferenceError: age没有定义 另一个重要的区别，就是let声明的变量不会在作用域中被提升 // name会被提升 console.log(name); // undefined var name = 'Matt'; // age不会被提升 console.log(age); // ReferenceError:age没有定义 let age = 26; let也不允许同一个块作用域中出现冗余声明。这样会导致报错 var name; var name; let age; let age; // SyntaxError；标识符age已经声明过了 嵌套使用相同的标识符不会报错 var name = 'Nicholas'; console.log(name); // 'Nicholas' if (true) { var name = 'Matt'; console.log(name); // 'Matt' } let age = 30; console.log(age); // 30 if (true) { let age = 26; console.log(age); // 26 } 对声明冗余报错不会因混用let和var而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。 var name; let name; // SyntaxError let age; var age; // SyntaxError 全局声明 使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）。 var name = 'Matt'; console.log(window.name); // 'Matt' let age = 26; console.log(window.age); // undefined 条件声明 在使用var声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为let的作用域是块，所以不可能检查前面是否已经使用let声明过同名变量，同时也就不可能在没有声明的情况下声明它。 \u003cscript\u003e var name = 'Nicholas'; let age = 26; \u003c/script\u003e \u003cscript\u003e // 假设脚本不确定页面中是否已经声明了同名变量 // 那它可以假设还没有声明过 var name = 'Matt'; // 这里没问题，因为可以被作为一个提升声明来处理 // 不需要检查之前是否声明过同名变量 let age = 36; // 如果age之前声明过，这里会报错 \u003c/script\u003e for循环中的let声明 在let出现之前，迭代变量可以在外面被访问到 for (var i = 0; i \u003c 5; ++i) { // 循环逻辑 } console.log(i); // 5 改成使用let之后，这个问题就消失了，因为迭代变量的作用域仅限于for循环块内部： for (let i = 0; i \u003c 5; ++i) { // 循环逻辑 } console.log(i); // ReferenceError: i没有定义 在使用var的时候，最常见的问题就是对迭代变量的奇特声明和修改： for (var i = 0; i \u003c 5; ++i) { setTimeout(() =\u003e console.log(i), 0) } // 你可能以为会输出0、1、2、3、4 // 实际上会输出5、5、5、5、5 for (let i = 0; i \u003c 5; ++i) { setTimeout(() =\u003e console.log(i), 0) } // 会输出0、1、2、3、4 const声明 const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误。 const age = 26; age = 36; // TypeError：给常量赋值 // const也不允许重复声明 const name = 'Matt'; const name = 'Nicholas'; // SyntaxError // const声明的作用域也是块 const name = 'Matt'; if (true) { const name = 'Nicholas'; } console.log(name); // Matt const声明的限制只适用于它指向的变量的引用。换句话说，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制。 const person = {}; person.name = 'Matt'; // ok 虽然const变量跟let变量很相似，但是不能用const来声明迭代变量（因为迭代变量会自增） for (const i = 0; i \u003c 10; ++i) {} // TypeError：给常量赋值 ⭐声明风格及最佳实践 不使用var const优先，let次之 对变量有修改的话使用 let，当然修改的是对象内部属性还是继续用 const ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:3:2","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"数据类型 ECMAScript有6种简单数据类型（也称为原始类型）: Undefined、Null、Boolean、Number、String和Symbol。Symbol（符号）是ECMAScript 6新增的。 还有一种复杂数据类型叫Object（对象）。Object是一种无序名值对的集合 typeof操作符 确定任意变量数据类型 对一个值使用typeof操作符会返回下列字符串之一：❑ “undefined\"表示值未定义；❑ “boolean\"表示值为布尔值；❑ “string\"表示值为字符串；❑ “number\"表示值为数值；❑ “object\"表示值为对象（而不是函数）或null；❑ “function\"表示值为函数；❑ “symbol\"表示值为符号。 let message = \"some string\"; console.log(typeof message); // \"string\" console.log(typeof(message)); // \"string\" console.log(typeof 95); // \"number\" 注意，因为typeof是一个操作符而不是函数，所以不需要参数（但可以使用参数）。 注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeof null返回的是\"object”。这是因为特殊值null被认为是一个对空对象的引用。 Undefined类型 Undefined类型只有一个值，就是特殊值undefined。 当使用var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined值： let message; console.log(message == undefined); // true undefined是一个假值。因此，如果需要，可以用更简洁的方式检测它 不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是undefined这个字面值，而不仅仅是假值。 let message; // 这个变量被声明了，只是值为undefined // age没有声明 if (message) { // 这个块不会执行-----------有数据返回时的处理 } if (! message) { // 这个块会执行 } if (age) { // 这里会报错 } Null类型-对象类型 Null类型同样只有一个值，即特殊值null。逻辑上讲，null值表示一个空对象指针，这也是给typeof传一个null会返回\"object\"的原因： let car = null; console.log(typeof car); // \"object\" 在定义将来要保存对象值的变量时，建议使用null来初始化，不要使用其他值 这样，只要检查这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如： if (car ! = null) { // car是一个对象的引用 } 用等于操作符（==）比较null和undefined始终返回true。但要注意，这个操作符会为了比较而转换它的操作数 假值检测 let message = null; let age; if (message) { // 这个块不会执行 } if (! message) { // 这个块会执行 } if (age) { // 这个块不会执行 } if (! age) { // 这个块会执行 } null和undefined 永远不必显式地将变量值设置为undefined。 任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用null来填充该变量。这样就可以保持null是空对象指针的语义，并进一步将其与undefined区分开来。 Boolean类型 有两个字面值：true和false。这两个布尔值不同于数值，因此true不等于1，false不等于0。 let found = true; let lost = false; ⚠注意：区分大小写 转换布尔值 let message = \"Hello world! \"; let messageAsBoolean = Boolean(message); 不同类型与布尔值之间的转换规则 Number类型 Number类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值） let octalNum1 = 070; // 八进制的56 let octalNum2 = 079; // 无效的八进制值，当成79 处理 let octalNum3 = 08; // 无效的八进制值，当成8 处理 浮点值 要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字 let floatNum1 = 1.1; let floatNum2 = 0.1; let floatNum3 = .1; // 有效，但不推荐 科学计数法 let floatNum = 3.125e7; // 等于31250000 永远不要测试某个特定的浮点值。 if (a + b == 0.3) { // 别这么干！ console.log(\"You got 0.3.\"); } 如果两个数值分别是0.05和0.25，或者0.15和0.15，那没问题。但如果是0.1和0.2，如前所述，测试将失败 值的范围 ECMAScript可以表示的最小数值保存在Number.MIN_VALUE中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在Number.MAX_VALUE中，这个值在多数浏览器中是1.797693134862315 7e+308。 NaN 有一个特殊的数值叫NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误） console.log(0/0); // NaN console.log(-0/+0); // NaN 数值转换 有3个函数可以将非数值转换为数值：Number()、parseInt()和parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。 Number()函数基于如下规则执行转换。 let num1 = Number(\"Hello world! \"); // NaN let num2 = Number(\"\"); // 0 let num3 = Number(\"000011\"); // 11 let num4 = Number(true); // 1 考虑到用Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用parseInt()函数 parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN。这意味着空字符串也会返回NaN（这一点跟Number()不一样，它返回0） let num1 = parseInt(\"1234blue\"); // 1234 let num2 = parseInt(\"\"); // NaN let num3 = parseInt(\"0xA\"); // 10，解释为十六进制整数 let num4 = parseInt(22.5); // 22 let num5 = parseInt(\"70\"); // 70，解释为十进制值 let num6 = parseInt(\"0xf\"); // 15，解释为十六进制整数 let num1 = parseInt(\"10\", 2); // 2，按二进制解析 let num2 = parseInt(\"10\", 8); // 8，按八进制解析 let num3 = parseInt(\"10\", 10); // 10，按十进制解析 let num4 = parseInt(\"10\", 16); // 16，按十六进制解析 parseFloat()函数的工作方式跟parseInt()函数类似，都是从位置0开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。 parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。 let num1 = parseFloat(\"1234blue\"); // 1234，按整数解析 let num2 = parseFloat(\"0xA\"); // 0 let num3 = parseFloat(\"22.5\"); // 22.5 let num4 = parseFloat(\"22.34.5\"); // 22.34 let num5 = parseFloat(\"0908.5\"); // 908.5 let num6 = parseFloat(\"3.125e7\"); // 31250000 String类型 String（字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（\"）、单引号（’）或反引号（`）标示，因此下面的代码都是合法的： let firstName = \"John\"; let lastName = 'Jacob'; let lastName = `Jingleheimerschmidt` 不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾 ECMAScript中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:3:3","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"函数 ECMAScript中的函数使用function关键字声明，后跟一组参数，然后是函数体。 函数的基本语法 function functionName(arg0, arg1, ..., argN) { statements } function sayHi(name, message) { console.log(\"Hello \" + name + \", \" + message); } 函数调用 sayHi(\"Nicholas\", \"how are you today? \"); 有返回值的函数 ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用return语句来返回函数的值，用法是后跟要返回的值 function sum(num1, num2) { return num1 + num2; } const result = sum(5, 10); 要注意的是，只要碰到return语句，函数就会立即停止执行并退出。因此，return语句后面的代码不会被执行 ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:3:4","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"第10章 函数 函数实际上是对象，每个函数都是Function类型的实例 因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定 ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:4:0","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"定义函数的方式 function sum (num1, num2) { return num1 + num2; } 函数表达式 let sum = function(num1, num2) { return num1 + num2; }; 注意这里的函数末尾是有分号的，与任何变量初始化语句一样 “箭头函数”（arrow function） let sum = (num1, num2) =\u003e { return num1 + num2; }; ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:4:1","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["读书笔记","编程笔记"],"content":"箭头函数 ","date":"2024-01-18","objectID":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/:4:2","tags":["JavaScript"],"title":"读书笔记 | JavaScript 高级程序设计（第四版）","uri":"/2024/01/18/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/"},{"categories":["English Daily"],"content":"Imagine that you have an ice cube sitting on the table in front of you. The room is cold and you can see your breath. It is currently twenty-five degrees. Ever so slowly, the room begins to heat up. Twenty-six degrees. Twenty-seven. Twenty-eight. The ice cube is still sitting on the table in front of you. Twenty-nine degrees. Thirty. Thirty-one. Still, nothing has happened. Then, thirty-two degrees. The ice begins to melt. A one-degree shift,seemingly no different from the temperature increases before it, has unlocked a huge change. This is one of the core reasons why it is so hard to build habits that last. Complaining about not achieving success despite working hard is like complaining about an ice cube not melting when you heated it from twenty-five to thirty-one degrees. What we should do? FORGET ABOUT GOALS, FOCUS ON SYSTEMS INSTEAD Goals are about the results you want to achieve. Systems are about the processes that lead to those results. 专注于要做的事情。 ","date":"2024-01-17","objectID":"/2024/01/17/day04-atomic-habits/:0:0","tags":["Atomic Habits"],"title":"day04 FORGET ABOUT GOALS, FOCUS ON SYSTEMS INSTEAD","uri":"/2024/01/17/day04-atomic-habits/"},{"categories":["Awesome"],"content":"教程 ","date":"2024-01-17","objectID":"/2024/01/17/javascript-awesome/:1:0","tags":["JavaScript"],"title":"JavaScript 常用网站\u0026资源汇总","uri":"/2024/01/17/javascript-awesome/"},{"categories":["Awesome"],"content":"快速入门 MDN Web Docs-JavaScript 廖雪峰 JavaScript教程 四十分钟JavaScript快速入门 | 无废话且清晰流畅 | 手敲键盘 ","date":"2024-01-17","objectID":"/2024/01/17/javascript-awesome/:1:1","tags":["JavaScript"],"title":"JavaScript 常用网站\u0026资源汇总","uri":"/2024/01/17/javascript-awesome/"},{"categories":["Awesome"],"content":"书籍推荐 《JavaScript DOM 编程艺术》 被推荐最多的前端入门书籍 《JavsScript高级程序设计（第三版）》 学习 JS 最好的书，学习 JS 每个阶段再去读，仍然会有收获。 You-Dont-Know-JS GitHub 上很火的 JS 教程，是英文版。中文是《你不知道的JavaScript》 可以用来提升自己对 JS 语法的理解程度。 ","date":"2024-01-17","objectID":"/2024/01/17/javascript-awesome/:1:2","tags":["JavaScript"],"title":"JavaScript 常用网站\u0026资源汇总","uri":"/2024/01/17/javascript-awesome/"},{"categories":["English Daily"],"content":"Habits are the compound interest of self-improvement. 习惯是自我提升的复利 They seem to make little difference on any given way and yet the impact they deliver over the months and years can be enormous. 他们在一天内看不到什么区别，但是几个月几年时间的积累产生的影响可能是巨大的。 We often dismiss small changes because they don’t seem to matter very much in the moment. If you save a little money now, you’re still not a millionaire. If you go to the gym three days in a row, you’re still out of shape. If you study Mandarin for an hour tonight, you still haven’t learned the language. We make a few changes, but the results never seem to come quickly and so we slide back into our previous routines. 我们经常忽略一些小的变化，因为它看起来没有那么重要。如果你现在省了一些钱，你不会是百万富翁。如果你去了三天健身房，你的身材仍旧走样。你一晚上学了一个小时普通话，还是不会这门语言。我们做了一些改变，但是结果并没有那么快来，所以我们又像往常一样。 A slight change in your daily habits can guide your life to a very different destination. That said, it doesn’t matter how successful or unsuccessful you are right now. What matters is whether your habits are putting you on the path toward success. 无所谓现在成不成功，重要的是你的习惯是否让你在通往成功的路上。 ","date":"2024-01-16","objectID":"/2024/01/16/day03-atomic-habits/:0:0","tags":["Atomic Habits"],"title":"day03 Your future depends on what you do now","uri":"/2024/01/16/day03-atomic-habits/"},{"categories":["Awesome"],"content":"React 官方网站 官网地址：https://react.dev/ GitHub 地址：https://github.com/facebook/react ","date":"2024-01-16","objectID":"/2024/01/16/react-awesome/:1:0","tags":["React"],"title":"React 常用网站\u0026资源汇总","uri":"/2024/01/16/react-awesome/"},{"categories":["Awesome"],"content":"教程 ","date":"2024-01-16","objectID":"/2024/01/16/react-awesome/:2:0","tags":["React"],"title":"React 常用网站\u0026资源汇总","uri":"/2024/01/16/react-awesome/"},{"categories":["Awesome"],"content":"文档 React 官方文档 React 官方中文文档 React 中文索引 React 菜鸟教程 ","date":"2024-01-16","objectID":"/2024/01/16/react-awesome/:2:1","tags":["React"],"title":"React 常用网站\u0026资源汇总","uri":"/2024/01/16/react-awesome/"},{"categories":["Awesome"],"content":"视频 黑马程序员前端React18入门到实战视频教程 有基础有实战，学完基础直接上手开发小案例 ","date":"2024-01-16","objectID":"/2024/01/16/react-awesome/:2:2","tags":["React"],"title":"React 常用网站\u0026资源汇总","uri":"/2024/01/16/react-awesome/"},{"categories":["Awesome"],"content":"开发框架 ","date":"2024-01-16","objectID":"/2024/01/16/react-awesome/:3:0","tags":["React"],"title":"React 常用网站\u0026资源汇总","uri":"/2024/01/16/react-awesome/"},{"categories":["Awesome"],"content":"Next.js Next.js 是一个用于生产环境的 React 框架，提供生产环境所需的所有功能以及最佳的开发体验：包括静态及服务器端融合渲染、 支持 TypeScript、智能化打包、 路由预取等功能 无需任何配置。 中文文档 ","date":"2024-01-16","objectID":"/2024/01/16/react-awesome/:3:1","tags":["React"],"title":"React 常用网站\u0026资源汇总","uri":"/2024/01/16/react-awesome/"},{"categories":["Awesome"],"content":"组件库 Material-UI 目前最强大和最流行的UI组件库之一，可以使用MUI轻松构建精美的UI，从谷歌的Material Design开始。 官网：https://mui.com/ Ant Design 蚂蚁集团体验技术部经过大量项目实践和总结，逐步打磨出一个服务于企业级产品的设计体系 —— Ant Design 官网：https://ant-design.antgroup.com/index-cn React Vant（移动端） 性能极佳的高质量组件库，覆盖移动端主流场景 Vant 是有赞前端团队开源的移动端组件库，于 2017 年开源。 官网：https://react-vant.3lang.dev/ ","date":"2024-01-16","objectID":"/2024/01/16/react-awesome/:4:0","tags":["React"],"title":"React 常用网站\u0026资源汇总","uri":"/2024/01/16/react-awesome/"},{"categories":["Awesome"],"content":"开箱即用后台模板 Ant Design Pro 蚂蚁开源的开箱即用的中台前端/设计解决方案。 更新非常快 bug 有点多 官网 | GitHub ","date":"2024-01-16","objectID":"/2024/01/16/react-awesome/:5:0","tags":["React"],"title":"React 常用网站\u0026资源汇总","uri":"/2024/01/16/react-awesome/"},{"categories":["Awesome"],"content":"社区 ","date":"2024-01-16","objectID":"/2024/01/16/react-awesome/:6:0","tags":["React"],"title":"React 常用网站\u0026资源汇总","uri":"/2024/01/16/react-awesome/"},{"categories":["编程笔记"],"content":"React 基础 React由Meta公司开发，是一个用于 构建Web和原生交互界面的库 The library for web and native user interfaces ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:1:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"React 优势 虚拟DOM（Virtual DOM） 使用虚拟DOM，通过比较前后两个状态的差异，最小化DOM操作，提高性能。 组件化 强调组件化开发，将用户界面划分为独立的、可复用的组件。 生态系统 拥有庞大的生态系统，许多公司和项目使用 React，有丰富的社区支持。 社区支持 拥有庞大的社区，得到了来自Facebook等大公司的支持。 适用场景 更适用于大型应用和需要高度定制化的项目。 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:2:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"React 开发环境搭建 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:3:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"create-react-app npx create-react-app react-project-name // 启动项目 npm start ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:3:1","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"Next.js Next.js 是生产级的 React 框架 https://zh-hans.react.dev/learn/start-a-new-react-project ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:3:2","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"组件: 组合页面 React 应用程序是由 组件 组成的。一个组件是 UI（用户界面）的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。经过组合，形成一整个页面。 React 组件是一个 JavaScript 函数 function MyButton() { return ( \u003cbutton\u003eI'm a button\u003c/button\u003e ); } 上述是 MyButton 组件的声明 现在把它嵌套到另一个组件中 export default function MyApp() { return ( \u003cdiv\u003e \u003ch1\u003eWelcome to my app\u003c/h1\u003e \u003cMyButton /\u003e \u003c/div\u003e ); } export default 关键字指定了文件中的主要组件。 React 组件必须以大写字母开头，而 HTML 标签则必须是小写字母。 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:4:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"JSX: 构建 UI JSX 是 React 中用来构建 UI 的方式。 JSX并不是标准的JS语法，它是 JS的语法扩展，浏览器本身不能识别，需要通过解析工具做解析之后才能在浏览器中使用 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:5:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"JSX 语法限制 必须闭合标签，如 \u003cbr /\u003e 组件不能返回多个 JSX 标签，必须将它们包裹到一个共享的父级中，比如 \u003cdiv\u003e...\u003c/div\u003e 或使用空的 \u003c\u003e...\u003c/\u003e 包裹 function AboutPage() { return ( \u003c\u003e \u003ch1\u003eAbout\u003c/h1\u003e \u003cp\u003eHello there.\u003cbr /\u003eHow do you do?\u003c/p\u003e \u003c/\u003e ); } ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:5:1","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"JSX 渲染数据 在JSX中可以通过 大括号语法{} 识别JavaScript中的表达式，比如常见的变量、函数调用、方法调用等等 注意：if语句、switch语句、变量声明不属于表达式，不能出现在{}中 const message = 'this is message' function getAge(){ return 18 } function App(){ return ( \u003cdiv\u003e \u003ch1\u003ethis is title\u003c/h1\u003e {/* 字符串识别 */} {'this is str'} {/* 变量识别 */} {message} {/* 函数调用 渲染为函数的返回值 */} {getAge()} \u003c/div\u003e ) } export default App; ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:5:2","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"map 方法实现列表渲染 const list = [ {id:1001, name:'Vue'}, {id:1002, name: 'React'}, {id:1003, name: 'Angular'} ] function App(){ return ( \u003cdiv\u003e \u003cul\u003e {list.map(item =\u003e \u003cli key={item.id}\u003e{item.name}\u003c/li\u003e)} \u003c/ul\u003e \u003c/div\u003e ) } export default App; 对于列表中的每一个元素，你都应该传递一个字符串或者数字给 key，用于在其兄弟节点中唯一标识该元素。 通常 key 来自你的数据，比如数据库中的 ID。如果你在后续插入、删除或重新排序这些项目，React 将依靠你提供的 key 来思考发生了什么。 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:5:3","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"逻辑符号实现条件渲染 逻辑与运算符 \u0026\u0026 const flag = false function App(){ return ( \u003cdiv\u003e {flag \u0026\u0026 \u003cspan\u003e测试条件渲染\u003c/span\u003e} \u003c/div\u003e ) } export default App; 三元表达式 (?:) const flag = false function App(){ return ( \u003cdiv\u003e {flag ? \u003cspan\u003eflag\u003c/span\u003e : \u003cspan\u003e测试\u003c/span\u003e} \u003c/div\u003e ) } export default App; ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:5:4","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"复杂条件渲染 解决方案：自定义函数 + 判断语句 const type = 1 // 0|1|3 function getArticleJSX(){ if(type === 0){ return \u003cdiv\u003e无图模式模版\u003c/div\u003e }else if(type === 1){ return \u003cdiv\u003e单图模式模版\u003c/div\u003e }else(type === 3){ return \u003cdiv\u003e三图模式模版\u003c/div\u003e } } function App(){ return ( \u003c\u003e { getArticleJSX() } \u003c/\u003e ) } ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:5:5","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"组件样式 CSS 在 React 中，可以使用 className 来指定一个 CSS 的 class。与 HTML 的 class 属性的工作方式相同： \u003cimg className=\"avatar\" /\u003e 可以在一个单独的 CSS 文件中为它编写 CSS 规则 /* In your CSS */ .avatar { border-radius: 50%; } React 并没有规定你如何添加 CSS 文件，言外之意，如何添加由你自己决定 行内样式 \u003cdiv style={{ color:'red'}}\u003ethis is div\u003c/div\u003e 变量抽取出来定义 const style = { color: 'red', fontSize: '100px' } function App() { return ( \u003cdiv\u003e \u003cspan style={style}\u003eHello\u003c/span\u003e! \u003c/div\u003e ); } export default App; ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:6:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"组件属性传参 props props可以传递任意的合法数据，比如数字、字符串、布尔值、数组、对象、函数、JSX const user = { name: 'Hedy Lamarr', imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg', imageSize: 90, }; export default function Profile() { return ( \u003c\u003e \u003ch1\u003e{user.name}\u003c/h1\u003e \u003cimg className=\"avatar\" src={user.imageUrl} alt={'Photo of ' + user.name} style={{ width: user.imageSize, height: user.imageSize }} /\u003e \u003c/\u003e ); } ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:7:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"React 事件绑定 React中的事件绑定，通过语法 on + 事件名称 = { 事件处理程序 }，整体上遵循驼峰命名法 function App(){ const clickHandler = ()=\u003e{ console.log('button按钮点击了') } return ( \u003cbutton onClick={clickHandler}\u003eclick me\u003c/button\u003e ) } 注意，onClick={handleClick} 的结尾没有小括号！不要 调用 事件处理函数：你只需 把函数传递给事件 即可。当用户点击按钮时 React 会调用你传递的事件处理函数。 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:8:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"事件参数 function App(){ const clickHandler = (e)=\u003e{ console.log('button按钮点击了', e) } return ( \u003cbutton onClick={clickHandler}\u003eclick me\u003c/button\u003e ) } ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:8:1","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"传递自定义参数 function App(){ const clickHandler = (name)=\u003e{ console.log('button按钮点击了', name) } return ( \u003cbutton onClick={()=\u003eclickHandler('jack')}\u003eclick me\u003c/button\u003e ) } ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:8:2","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"同时传递事件对象和自定义参数 在事件绑定的位置传递事件实参e和自定义参数，clickHandler中声明形参，注意顺序对应 function App(){ const clickHandler = (name,e)=\u003e{ console.log('button按钮点击了', name,e) } return ( \u003cbutton onClick={(e)=\u003eclickHandler('jack',e)}\u003eclick me\u003c/button\u003e ) } ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:8:3","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"更新界面(状态管理)-useState useState 是一个 React Hook（函数），它允许我们向组件添加一个状态变量, 从而控制影响组件的渲染结果 和普通JS变量不同的是，状态变量一旦发生变化组件的视图UI也会跟着变化（数据驱动视图） 其中的数据改变，渲染出的视图 UI 就会跟着发生变化 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:9:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"基础使用 function App(){ const [ count, setCount ] = React.useState(0) return ( \u003cdiv\u003e \u003cbutton onClick={()=\u003esetCount(count+1)}\u003e{ count }\u003c/button\u003e \u003c/div\u003e ) } ⚠注意 useState 参数可以用来初始化，传什么样的类型，操作的就是什么样的类型 状态修改只能用 set...方法 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:9:1","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"修改对象状态 对于对象类型的状态变量，应该始终给set方法一个全新的对象 来进行修改 import {useState} from \"react\"; function App(){ const [Object, setObject] = useState({name:'leo'}) const handleChangeName = () =\u003e { setObject({ ...Object, name:'jack' }) } return ( \u003cdiv\u003e {Object.name} \u003cbutton onClick={handleChangeName}\u003ebutton\u003c/button\u003e \u003c/div\u003e ) } export default App; ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:9:2","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"Hook 函数 以 use 开头的函数被称为 Hook。useState 是 React 提供的一个内置 Hook Hook 函数只能在你的组件（或其他 Hook）的 顶层 调用 Hook。如果你想在一个条件或循环中使用 useState，请提取一个新的组件并在组件内部使用它。 更多 Hook 函数 React API 参考 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:10:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"自定义 Hook 函数 // 封装自定义Hook // 问题: 布尔切换的逻辑 当前组件耦合在一起的 不方便复用 // 解决思路: 自定义hook import { useState } from \"react\" function useToggle () { // 可复用的逻辑代码 const [value, setValue] = useState(true) const toggle = () =\u003e setValue(!value) // 哪些状态和回调函数需要在其他组件中使用 return return { value, toggle } } // 封装自定义hook通用思路 // 1. 声明一个以use打头的函数 // 2. 在函数体内封装可复用的逻辑（只要是可复用的逻辑） // 3. 把组件中用到的状态或者回调return出去（以对象或者数组） // 4. 在哪个组件中要用到这个逻辑，就执行这个函数，解构出来状态和回调进行使用 function App () { const { value, toggle } = useToggle() return ( \u003cdiv\u003e {value \u0026\u0026 \u003cdiv\u003ethis is div\u003c/div\u003e} \u003cbutton onClick={toggle}\u003etoggle\u003c/button\u003e \u003c/div\u003e ) } export default App ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:10:1","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"React Hooks使用规则 只能在组件中或者其他自定义Hook函数中调用 只能在组件的顶层调用，不能嵌套在if、for、其它的函数中 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:10:2","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"组件间共享数据 控制两个 Button 同时发生改变 import { useState } from 'react'; export default function MyApp() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( \u003cdiv\u003e \u003ch1\u003eCounters that update together\u003c/h1\u003e \u003cMyButton count={count} onClick={handleClick} /\u003e \u003cMyButton count={count} onClick={handleClick} /\u003e \u003c/div\u003e ); } function MyButton({ count, onClick }) { return ( \u003cbutton onClick={onClick}\u003e Clicked {count} times \u003c/button\u003e ); } ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:11:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"React副作用管理-useEffect useEffect是一个React Hook函数，用于在React组件中创建不是由事件引起而是由渲染本身引起的操作（副作用）, 比如发送AJAX请求，更改DOM等等 组件渲染完毕之后就需要和服务器要数据，整个过程属于“只由渲染引起的操作” ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:12:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"基础使用 需求：在组件渲染完毕之后，立刻从服务端获取平道列表数据并显示到页面中 useEffect(() =\u003e {}, []) 参数1是一个函数，可以把它叫做副作用函数，在函数内部可以放置要执行的操作 参数2是一个数组（可选参），在数组里放置依赖项，不同依赖项会影响第一个参数函数的执行，当是一个空数组的时候，副作用函数只会在组件渲染完毕之后执行一次 依赖项 副作用功函数的执行时机 没有依赖项 组件初始渲染 + 组件更新时执行 空数组依赖 只在初始渲染时执行一次 添加特定依赖项 组件初始渲染 + 依赖项变化时执行 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:12:1","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"清除副作用 概念：在useEffect中编写的由渲染本身引起的对接组件外部的操作，社区也经常把它叫做副作用操作 比如在useEffect中开启了一个定时器，我们想在组件卸载时把这个定时器再清理掉，这个过程就是清理副作用 清除副作用的函数最常见的执行时机是在组件卸载时自动执行 import { useEffect, useState } from \"react\" function Son () { // 1. 渲染时开启一个定时器 useEffect(() =\u003e { const timer = setInterval(() =\u003e { console.log('定时器执行中...') }, 1000) return () =\u003e { // 清除副作用(组件卸载时) clearInterval(timer) } }, []) return \u003cdiv\u003ethis is son\u003c/div\u003e } function App () { // 通过条件渲染模拟组件卸载 const [show, setShow] = useState(true) return ( \u003cdiv\u003e {show \u0026\u0026 \u003cSon /\u003e} \u003cbutton onClick={() =\u003e setShow(false)}\u003e卸载Son组件\u003c/button\u003e \u003c/div\u003e ) } export default App ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:12:2","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"ReactRouter 一个路径 path 对应一个组件 component 。 当我们在浏览器中访问一个 path 的时候，path 对应的组件会在页面中进行渲染 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:13:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"路由引入 # 安装最新的ReactRouter包 npm i react-router-dom ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:13:1","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"基本使用 import React from 'react' import ReactDOM from 'react-dom/client' const router = createBrowserRouter([ { path:'/login', element: \u003cdiv\u003e登录\u003c/div\u003e }, { path:'/article', element: \u003cdiv\u003e文章\u003c/div\u003e } ]) ReactDOM.createRoot(document.getElementById('root')).render( \u003cRouterProvider router={router}/\u003e ) ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:13:2","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"路由抽取 router.js import {createBrowserRouter} from \"react-router-dom\"; import Login from \"../page/Login\"; import Article from \"../page/Article\"; const router = createBrowserRouter([ { path:'/login', element: \u003cLogin/\u003e }, { path:'/article', element: \u003cArticle/\u003e } ]) export default router index.js import React from 'react'; import ReactDOM from 'react-dom/client'; import './index.css'; import reportWebVitals from './reportWebVitals'; import router from \"./router\"; import {RouterProvider} from \"react-router-dom\"; ReactDOM.createRoot(document.getElementById('root')).render( \u003cRouterProvider router={router}/\u003e ) // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals(); 页面(也可以用 jsx) const Article = () =\u003e { return \u003cdiv\u003e我是文章页\u003c/div\u003e } export default Article ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:13:3","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"路由导航 路由系统中的多个路由之间需要进行路由跳转，并且在跳转的同时有可能需要传递参数进行通信 声明式导航 声明式导航是指通过在模版中通过 \u003cLink/\u003e 组件描述出要跳转到哪里去，比如后台管理系统的左侧菜单通常使用这种方式进行 \u003cLink to={\"/article\"}\u003e文章页\u003c/Link\u003e 语法说明：通过给组件的to属性指定要跳转到路由path，组件会被渲染为浏览器支持的a链接，如果需要传参直接通过字符串拼接的方式拼接参数即可 编程式导航 编程式导航是指通过 useNavigate 钩子得到导航方法，然后通过调用方法以命令式的形式进行路由跳转，比如想在登录请求完毕之后跳转就可以选择这种方式，更加灵活 只需要调用 navigate 方法就能跳转 语法说明：通过调用navigate方法传入地址path实现跳转 import {Link, useNavigate} from \"react-router-dom\"; const Login = () =\u003e { const navicate = useNavigate() return ( \u003cdiv\u003e 我是登录页 \u003cLink to={\"/article\"}\u003e文章页\u003c/Link\u003e {/* 命令式*/} \u003cbutton onClick={()=\u003enavicate('/article')}\u003e跳转到文章页\u003c/button\u003e \u003c/div\u003e ) } export default Login ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:13:4","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"导航传参 searchParam 传参 导航跳转-路由拼接传参 import {Link, useNavigate} from \"react-router-dom\"; const Login = () =\u003e { const navicate = useNavigate() return ( \u003cdiv\u003e 我是登录页 \u003cLink to={\"/article\"}\u003e文章页\u003c/Link\u003e {/* 命令式 */} \u003cbutton onClick={() =\u003e navicate('/article')}\u003e跳转到文章页\u003c/button\u003e {/* 导航 search 传参 */} \u003cbutton onClick={() =\u003e navicate('/article?id=1001\u0026name=jack')}\u003e导航 search 传参\u003c/button\u003e \u003c/div\u003e ) } export default Login 接收参数-useSearchParams import {useSearchParams} from \"react-router-dom\"; const Article = () =\u003e { const [params] = useSearchParams() const name = params.get('name') return \u003cdiv\u003e我是文章页 获取到的参数-{name}\u003c/div\u003e } export default Article params 传参 步骤 路径添加参数 路由占位符 获取参数-useParams 可以加多个，只需要添加占位符即可 路径添加参数 import {Link, useNavigate} from \"react-router-dom\"; const Login = () =\u003e { const navicate = useNavigate() return ( \u003cdiv\u003e {/* 导航 params 传参 */} \u003cbutton onClick={() =\u003e navicate('/article/jack')}\u003e导航 params 传参\u003c/button\u003e \u003c/div\u003e ) } export default Login 路由占位符 import {createBrowserRouter} from \"react-router-dom\"; import Login from \"../page/Login\"; import Article from \"../page/Article\"; const router = createBrowserRouter([ { path:'/login', element: \u003cLogin/\u003e }, { path:'/article/:name', element: \u003cArticle/\u003e } ]) export default router 获取参数 import {useParams, useSearchParams} from \"react-router-dom\"; const Article = () =\u003e { const params1= useParams() let nameParams = params1.name return \u003cdiv\u003e---- params 传参 {nameParams} \u003c/div\u003e } export default Article ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:13:5","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"嵌套路由 在一级路由中又内嵌了其他路由，这种关系就叫做嵌套路由 嵌套路由配置 实现步骤 1. 使用 `children`属性配置路由嵌套关系 2. 使用 `\u003cOutlet/\u003e` 组件配置二级路由渲染位置 嵌套路由配置 { path: '/', element: \u003cLayout/\u003e, children: [ { path: 'board', element: \u003cBoard/\u003e }, { path: 'about', element: \u003cAbout/\u003e } ] } 使用 \u003cOutlet/\u003e 组件配置二级路由渲染位置 Layout import {Link, Outlet} from \"react-router-dom\"; const Layout = () =\u003e { return ( \u003cdiv\u003e 我是一级路由组件 Layout {/* 用来跳转的按钮*/} \u003cLink to={'/board'}\u003e面板\u003c/Link\u003e \u003cLink to={'/about'}\u003e关于\u003c/Link\u003e {/* 配置二级路由出口，页面就在这个地方渲染 */} \u003cOutlet/\u003e \u003c/div\u003e ) } export default Layout 默认二级路由配置 当访问的是一级路由时，默认的二级路由组件可以得到渲染，只需要在二级路由的位置去掉path，设置index属性为true { path: '/', element: \u003cLayout/\u003e, children: [ { index: true, element: \u003cBoard/\u003e }, { path: 'about', element: \u003cAbout/\u003e } ] } ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:13:6","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"404 路由配置 场景：当浏览器输入url的路径在整个路由配置中都找不到对应的 path，为了用户体验，可以使用 404 兜底组件进行渲染 实现步骤： 准备一个NotFound组件 在路由表数组的末尾，以*号作为路由path配置路由 { path:'*', element: \u003cNotFound/\u003e } ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:13:7","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"两种路由模式 各个主流框架的路由常用的路由模式有俩种，history模式和hash模式, ReactRouter分别由 createBrowerRouter 和 createHashRouter 函数负责创建 路由模式 url表现 底层原理 是否需要后端支持 history url/login history对象 + pushState事件 需要 hash url/#/login 监听hashChange事件 不需要 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:13:8","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["编程笔记"],"content":"参考 React 官方文档 React 官方中文文档 黑马前端 React 18 文档 ","date":"2024-01-16","objectID":"/2024/01/16/react-base/:14:0","tags":["React"],"title":"React 基础","uri":"/2024/01/16/react-base/"},{"categories":["Awesome"],"content":"Awesome 介绍 Awesome 是在 GitHub 中一个经过精选和认可的高质量资源列表，以帮助用户发现与特定主题或领域相关的有价值的资源。这些资源列表通常包含与特定主题、技术或领域相关的链接、工具、库、框架、教程或其他资源。 “awesome\"前缀的资源列表通常由社区成员创建和维护，旨在为其他人提供一个精选的资源集合，以帮助他们在特定主题或领域中找到有用的工具、资料和参考资料。这些列表往往是开源的，任何人都可以通过提交请求或提供建议来增加或改进列表中的内容。 使用\"awesome\"前缀的资源列表通常具有一定的标准，以确保列出的资源具有高质量和广泛认可度。这可以帮助使用者在众多可用资源中筛选出最佳的选择，节省时间和精力。 以上内容由 ChatGPT 生成 ","date":"2024-01-16","objectID":"/2024/01/16/awesome/:1:0","tags":["词条"],"title":"什么是 Awesome | Awesome 系列","uri":"/2024/01/16/awesome/"},{"categories":["Awesome"],"content":"热门 awesome 仓库 awesome 关于各种有趣话题的列表 awesome-python 一份很棒的Python框架、库、软件和资源的列表 awesome-go 一份很棒的Go框架、库和软件的列表 awesome-java 一份关于Java编程语言的很棒的框架、库和软件的列表。 awesome-chatgpt-prompts This repo includes ChatGPT prompt curation to use ChatGPT better. awesome-chatgpt-prompts-zh ChatGPT 中文调教指南。各种场景使用指南。学习怎么让它听你的话。 awesome-courses 学习计算机科学的很棒的大学课程列表! 后端架构师技术图谱 后端架构师技术图谱 awesome-react 关于React生态系统的一系列很棒的东西 awesome-for-beginners 一份对初学者友好的项目清单。 ","date":"2024-01-16","objectID":"/2024/01/16/awesome/:2:0","tags":["词条"],"title":"什么是 Awesome | Awesome 系列","uri":"/2024/01/16/awesome/"},{"categories":["English Daily"],"content":"1% worse every day for one year. 0.99^365 = 00.03 1% better every day for one year. 1.01^365 = 37.78 ","date":"2024-01-15","objectID":"/2024/01/15/day02-atomic-habits/:0:0","tags":["Atomic Habits"],"title":"day02 1% better every day","uri":"/2024/01/15/day02-atomic-habits/"},{"categories":["读书笔记"],"content":"前言 《认知觉醒: 开启自我改变的原动力》这本书排在微信读书总榜 Top200 前 50，截止我写这篇读书笔记，有 185.2 万人阅读了这本书，微信读书推荐值 90%，豆瓣评分 8.1。究竟是怎样的一本书才能收到这么多人的好评？ 2017年，作者周岭 36 岁。古人讲三十而立，但作者在这个年纪还是决定去探索自己的认知觉醒道路。分享自己的的觉醒之旅，成为自媒体人，探索出了属于自己的一条觉醒之路。 书中有这样一句话：“我发现每天有事情做不代表觉醒，每天都努力也不代表觉醒，真正的觉醒是一种发自内心的渴望，立足长远，保持耐心，运用认知的力量与时间做朋友；我发现人与人之间的根本差异是认知能力上的差异，因为认知影响选择，而选择改变命运，所以成长的本质就是让大脑的认知变得更加清晰”。——成长的本质就是让自己大脑变得更加清晰，认知影响选择，选择改变命运。 我们通常所说的读万卷书，行万里路，其实就是在不断塑造你的认知。读书使人明智，你会接触到各种各样的思想，看到别人基于他们的认知背景做出的选择；行万里路，你会经历、看到各种各样的人和事儿。 ","date":"2024-01-15","objectID":"/2024/01/15/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E6%9E%84%E5%BB%BA%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80/:1:0","tags":["元认知","习惯"],"title":"读书笔记 | 认知觉醒：构建自我认知的基础","uri":"/2024/01/15/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E6%9E%84%E5%BB%BA%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["读书笔记"],"content":"最底层的认知能力：元认知 元认知能力其实就是我们通常所说的反思能力。有元认知能力，我们就可以从一个第三方视角反观自己。 元认知能力可以让我们做事情越来越得心应手。为什么同样一批人，一些人做的越来越得心应手，而另一些人还是老样子呢？差别就在反思能力上。有元认知能力的人做完一件事情后会去思考有什么经验可以积累下来，有什么问题可以继续改进，这样他的经验会越来越丰富。类似做过的事情，有最佳实践可以快速完成；容易出现问题的地方也多加注意改正。不断的反思，积累经验，就形成了一个正循环，就不难理解“越来越得心应手”了。 元认知能力可以让我们头脑保持清晰。一件事情为什么没办法坚持下去，其实很大的概率是我们忘了。你出门买菜，让你买牛奶、面包、芹菜，你可以轻而易举的记住。但是当要买的东西有7个之多呢，还是乖乖拿出纸笔记录下来。人脑决定了我们没办法一次记忆7个以上的观点，大部分事物的细节，大脑会帮我们处理掉。有了元认知，我们可以在一个阶段或者一天开始结束时，写一写自己的目标，明确下一步要做的事情，想清楚长远的意义和动机。你满脑子都是这件事，是不是行动的概率就大了呢？ 很多大佬都有写日记的习惯，其实就是利用了元认知能力，觉察自己，提升自己。张一鸣在微博记录了几年日记；王兴在饭否也会记录自己的思考；曾国藩也会每天写日记；俞敏洪为什么能够出版那么多本书，我想就是平时的积累，写下自己对于事物的观察思考。 怎么克服焦虑？把这件事写到纸上，反观一下，他其实并没有你想象的那么严重；再写下解决方案，你就会发现这件事是可以解决的，那还焦虑什么？ 作者在书中写到人生是一场消除模糊的比赛。我们可以学习知识，消除认知模糊；拆解烦恼，消除情绪模糊；里清外明，消除行动模糊。我认为最本质的就在于元认知能力，无论遇到什么问题，我们可以以一个第三视角去分析他，消除我们对于这个问题认知上的模糊，问题自然被拆解变得可以解决了。 ","date":"2024-01-15","objectID":"/2024/01/15/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E6%9E%84%E5%BB%BA%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80/:2:0","tags":["元认知","习惯"],"title":"读书笔记 | 认知觉醒：构建自我认知的基础","uri":"/2024/01/15/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E6%9E%84%E5%BB%BA%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["读书笔记"],"content":"构建基础，养成习惯：早冥读写跑 习惯是我们必备的一个工具，不管任何事情，一旦养成习惯，我们就可以毫不费力的去持续做这件事。一天早起，一次跑步没什么，一旦你养成习惯，做到每天，你就会发现事情发生了大变化。 早起可以利用几分钟的时间规划一下一天，写写日记。也可以读书写作，现在大部分人的习惯都是晚睡晚起，你可以利用这个时间进行自我提升，不会收到任何“紧急”事务的打扰。这个时间也是精力最充沛的时候，可以去攻克难题。 冥想被一些顶尖人物，比尔盖茨、尤瓦尔·赫拉利（《人类简史》的作者）所应用。书中提到，科学研究表明，通过这种集中注意力的冥想练习，人大脑皮层表面积增大，大脑灰质变厚，这意味着这种练习可以从物理上让我们变得更加聪明，因为一个人大脑皮层表面积和大脑灰质厚度是影响人聪明程度的因素。我自己并没有明显感觉到冥想的作用。我只是用他来快速休息，午休我会伴随着冥想语音的引导休息。 读书的作用不必多言，查理芒格曾经说过，我认识的有成就的人没有一个不在每天阅读。读书就是用最低廉的成本获取最高级的成长策略 写作，我前面提到的写日记就是一个开始，通过写作可以提高你的沟通能力，表达能力，清晰目标，对抗焦虑。写作是最好的学习方式，你写下一遍文章就是在调用你大脑里的千军万马，你脑子里的知识会建立各种联结，思维也会更加活跃。写作也是为数不多可以让你的时间变成多份的工具，你可以写一篇文章，出一本书影响更多人。 跑步，身体是革命的本钱。经常运动的人看起来精力充沛，充满活力。运动也能够使大脑长出更多的神经元，这意味着也许可以通过运动变聪明。好的模式是：运动+学习。书中提到，在运动后的1~2小时内进行高强度、高难度的脑力活动，比如阅读、解题、背记、写作、编程，等等，或是一些需要复杂技巧的体力活动，诸如舞蹈、钢琴，以及参加不同于以往的社交活动，如接触新的环境、人物或事物，这么做可以让新的神经元受到刺激，不断生长。换句话说，运动之后，脑子需要充分接受考验或挑战，才能让自己不断地变“聪明”。 ","date":"2024-01-15","objectID":"/2024/01/15/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E6%9E%84%E5%BB%BA%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80/:3:0","tags":["元认知","习惯"],"title":"读书笔记 | 认知觉醒：构建自我认知的基础","uri":"/2024/01/15/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E6%9E%84%E5%BB%BA%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["读书笔记"],"content":"总结 书中还提到了专注力、学习力、行动力、情绪力，大家觉得自己哪方面需要提升可以自己去读。 这本书给我最大的启示和共鸣是： 构建元认知能力，不断反思优化 早冥读写跑——自我改变的基础。 构建好自己是不断前进的第一步。 ","date":"2024-01-15","objectID":"/2024/01/15/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E6%9E%84%E5%BB%BA%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80/:4:0","tags":["元认知","习惯"],"title":"读书笔记 | 认知觉醒：构建自我认知的基础","uri":"/2024/01/15/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E6%9E%84%E5%BB%BA%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["English Daily"],"content":"Atomic Habits 阅读","date":"2024-01-14","objectID":"/2024/01/14/day01-atomic-habits/","tags":["Atomic Habits"],"title":"day01 minor remarkable","uri":"/2024/01/14/day01-atomic-habits/"},{"categories":["English Daily"],"content":"Changes that seem small and unimportant at first will compound remarkable results if you are willing to stick with them for years. The pieces of things that are minor, but give you a sense of control over your life and you feel confident. ","date":"2024-01-14","objectID":"/2024/01/14/day01-atomic-habits/:0:0","tags":["Atomic Habits"],"title":"day01 minor remarkable","uri":"/2024/01/14/day01-atomic-habits/"},{"categories":["技术"],"content":"1. 创建两个仓库 一个用来存放 Hugo 源文件，私有、公有都可以 一个用来托管网站，用户名.github.io ","date":"2024-01-14","objectID":"/2024/01/14/github-page-deploy/:1:0","tags":["部署","Github Action"],"title":"Github Action 自动部署发布","uri":"/2024/01/14/github-page-deploy/"},{"categories":["技术"],"content":"2. 生成部署密钥 ssh-keygen -t rsa -b 4096 -C user.email 这种方式可以输入自定义的路径来保存SSH Key，这样就不会影响到电脑中旧的SSH Key。 生成过程中要输入生成密钥路径：/xx/xx/.ssh/id_rsa_hugo_deploy id_rsa_hugo_deploy.pub (public key) id_rsa_hugo_deploy (private key) ","date":"2024-01-14","objectID":"/2024/01/14/github-page-deploy/:2:0","tags":["部署","Github Action"],"title":"Github Action 自动部署发布","uri":"/2024/01/14/github-page-deploy/"},{"categories":["技术"],"content":"3. 填写密钥 将 Public Key 填写到username.github.io 点击 Settings，再点击Deploy keys，填写 Public Key 记得勾上 Allow write access 将 Private Key 添加到 Hugo 源文件仓库 点击 Settings，再点击 Secrets，填写 Private Key 变量名要复制下来，一会儿要用 ","date":"2024-01-14","objectID":"/2024/01/14/github-page-deploy/:3:0","tags":["部署","Github Action"],"title":"Github Action 自动部署发布","uri":"/2024/01/14/github-page-deploy/"},{"categories":["技术"],"content":"4. 编写 Github Actions 脚本 为 Hugo 源文件仓库配置 Actions name: Hugo Github Pages on: push: # push 的时候触发 branches: # 分支触发 - main jobs: build: runs-on: ubuntu-latest # 镜像市场 steps: - name: checkout uses: actions/checkout@master #软件市场的名称 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true - name: Build # 编译 run: hugo --minify - name: Deploy # 部署 uses: peaceiris/actions-gh-pages@v2 env: ACTIONS_DEPLOY_KEY: ${{ secrets.HUGO_SECRET_NAME }} #用到 secrets变量名 EXTERNAL_REPOSITORY: username/username.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public ","date":"2024-01-14","objectID":"/2024/01/14/github-page-deploy/:4:0","tags":["部署","Github Action"],"title":"Github Action 自动部署发布","uri":"/2024/01/14/github-page-deploy/"}]